From 5ade9779f6a3286d5c0be30300b83ffb04c835b8 Mon Sep 17 00:00:00 2001
From: Chaitanya Tata <Chaitanya.Tata@imgtec.com>
Date: Tue, 30 Aug 2016 13:55:14 +0530
Subject: [PATCH 2/3] uccp420wlan: Fixes and Feature additions

Release 6.8 Updates.

1) SBM issues fixed
	a) BUG01884 - Wifi performance issue with kernel 4.4 (high ping latency in 4.4)
	b) REQ01895 - Wifi: Add interface to change multicast TX rate
2) Fixes for handling 64MB external RAM access limitation.
3) Fixed LMAC probably stuck driver warning while disconnecting.
4) Enabled TX fast path in mac80211.
5) TX path optimization - Early Release of Frames failing the AMPDU criterion rather than buffering.
6) Fix for driver crash during a race Proc read Vs. Interface De-initialization.
7) hal_init code cleanup patch from IMGWorks.
8) Code review comments from IMGWorks - around 50% changes done.
9) Version bumped to 6.0.5.

Change-Id: I985bd79e9e079f293cff1cbf4ece8cebf677e68e
---
 drivers/net/wireless/uccp420wlan/Makefile          |   2 +
 drivers/net/wireless/uccp420wlan/inc/core.h        | 250 ++++++--
 drivers/net/wireless/uccp420wlan/inc/fwldr.h       |   3 +-
 .../net/wireless/uccp420wlan/inc/host_umac_if.h    |  19 +
 drivers/net/wireless/uccp420wlan/inc/umac_if.h     |   3 +
 drivers/net/wireless/uccp420wlan/inc/version.h     |   2 +-
 drivers/net/wireless/uccp420wlan/src/80211_if.c    | 684 +++++++++++----------
 drivers/net/wireless/uccp420wlan/src/core.c        | 318 ++++++----
 drivers/net/wireless/uccp420wlan/src/fwldr.c       |   8 +-
 .../net/wireless/uccp420wlan/src/hal_hostport.c    | 231 +++----
 drivers/net/wireless/uccp420wlan/src/tx.c          | 531 ++++++++++++----
 drivers/net/wireless/uccp420wlan/src/umac_if.c     | 359 ++++++-----
 12 files changed, 1556 insertions(+), 854 deletions(-)

diff --git a/drivers/net/wireless/uccp420wlan/Makefile b/drivers/net/wireless/uccp420wlan/Makefile
index d9d0c16..d46e8e7 100644
--- a/drivers/net/wireless/uccp420wlan/Makefile
+++ b/drivers/net/wireless/uccp420wlan/Makefile
@@ -2,5 +2,7 @@ uccp420wlan-objs		:= src/80211_if.o src/core.o src/umac_if.o src/tx.o src/hal_ho
 ccflags-y += -DMULTI_CHAN_SUPPORT
 obj-$(CONFIG_UCCP420WLAN)	+= uccp420wlan.o
 ccflags-y += -I$(src)/inc
+#Needed for Run Time Debug support
+ccflags-y += -DDEBUG
 
 
diff --git a/drivers/net/wireless/uccp420wlan/inc/core.h b/drivers/net/wireless/uccp420wlan/inc/core.h
index 35cd4cd..d635ff8 100755
--- a/drivers/net/wireless/uccp420wlan/inc/core.h
+++ b/drivers/net/wireless/uccp420wlan/inc/core.h
@@ -26,25 +26,25 @@
 #ifndef _UCCP420WLAN_CORE_H_
 #define _UCCP420WLAN_CORE_H_
 
-#include <linux/version.h>
-#include <linux/spinlock.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
 #include <linux/skbuff.h>
+#include <linux/spinlock.h>
 #include <linux/timer.h>
-#include <linux/delay.h>
+#include <linux/version.h>
 #include <linux/wireless.h>
-#include <linux/sched.h>
-#include <linux/jiffies.h>
 
-#include <linux/interrupt.h>
 #include <net/mac80211.h>
 
-#include <linux/dma-mapping.h>
-#include <linux/atomic.h>
-#include <linux/etherdevice.h>
 
+#include "descriptors.h"
 #include "host_umac_if.h"
 #include "umac_if.h"
-#include "descriptors.h"
 
 extern unsigned int vht_support;
 extern struct cmd_send_recv_cnt cmd_info;
@@ -56,28 +56,38 @@ extern unsigned char rx_interrupt_status;
 #endif
 
 
-#define UCCP_DEBUG_TX(fmt, ...)				    \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_TX)		                \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_TX(fmt, ...)			\
+do {                                             \
+	if (uccp_debug & UCCP_DEBUG_TX)		  \
+		pr_debug(fmt, ##__VA_ARGS__);      \
 } while (0)
 
-#define UCCP_DEBUG_SCAN(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_SCAN)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_SCAN(fmt, ...)            \
+do {                                          \
+	if (uccp_debug & UCCP_DEBUG_SCAN)      \
+		pr_debug(fmt, ##__VA_ARGS__);   \
 } while (0)
 
-#define UCCP_DEBUG_ROC(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_ROC)			\
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_ROC(fmt, ...)            \
+do {                                         \
+	if (uccp_debug & UCCP_DEBUG_ROC)      \
+		pr_debug(fmt, ##__VA_ARGS__);  \
 } while (0)
 
-#define UCCP_DEBUG_TSMC(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_TSMC)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_TSMC(fmt, ...)             \
+do {                                           \
+	if (uccp_debug & UCCP_DEBUG_TSMC)       \
+		pr_debug(fmt, ##__VA_ARGS__);    \
+} while (0)
+
+/* Wrapper to check return values for all
+ * umac_if layer calls.
+ */
+#define CALL_UMAC(prog_umac, ...) \
+do {                            \
+	ret = prog_umac(__VA_ARGS__);   \
+	if (ret != 0)                    \
+		goto prog_umac_fail;      \
 } while (0)
 
 #ifdef CONFIG_NL80211_TESTMODE
@@ -136,6 +146,9 @@ extern spinlock_t tsf_lock;
 #define QUEUE_FLUSH_TIMEOUT  2000   /* Specify delay in milli-seconds*/
 #define QUEUE_FLUSH_TIMEOUT_TICKS   msecs_to_jiffies(QUEUE_FLUSH_TIMEOUT)
 
+#define TX_DEINIT_TIMEOUT 5000
+#define TX_DEINIT_TIMEOUT_TICKS msecs_to_jiffies(TX_DEINIT_TIMEOUT)
+
 #ifdef CONFIG_PM
 #define PS_ECON_CFG_TIMEOUT 1000
 #define PS_ECON_CFG_TIMEOUT_TICKS msecs_to_jiffies(PS_ECON_CFG_TIMEOUT)
@@ -173,6 +186,10 @@ extern spinlock_t tsf_lock;
 #define BTS_AP_24GHZ_ETS 195 /* Microsecs */
 #define BTS_AP_5GHZ_ETS 25 /* Microsecs */
 
+enum ptype {
+	UCAST = 0,
+	MCAST
+};
 
 enum noa_triggers {
 	FROM_TX = 0,
@@ -180,24 +197,29 @@ enum noa_triggers {
 	FROM_EVENT_NOA
 };
 
+enum tx_deinit {
+	TX_FLUSH = 0,
+	TX_DROP,
+};
+
 enum uccp420_hw_scan_status {
 	HW_SCAN_STATUS_NONE,
 	HW_SCAN_STATUS_PROGRESS
 };
 
 enum uccp_debug {
-	UCCP_DEBUG_SCAN			= BIT(0),
-	UCCP_DEBUG_ROC			= BIT(1),
-	UCCP_DEBUG_TX			= BIT(2),
-	UCCP_DEBUG_CORE			= BIT(3),
-	UCCP_DEBUG_IF			= BIT(4),
-	UCCP_DEBUG_80211IF		= BIT(5),
-	UCCP_DEBUG_RX			= BIT(6),
-	UCCP_DEBUG_HAL			= BIT(7),
-	UCCP_DEBUG_CRYPTO		= BIT(8),
-	UCCP_DEBUG_DUMP_RX		= BIT(9),
-	UCCP_DEBUG_DUMP_HAL		= BIT(10),
-	UCCP_DEBUG_TSMC			= BIT(11),
+	UCCP_DEBUG_SCAN			= BIT(1),
+	UCCP_DEBUG_ROC			= BIT(2),
+	UCCP_DEBUG_TX			= BIT(3),
+	UCCP_DEBUG_CORE			= BIT(4),
+	UCCP_DEBUG_IF			= BIT(5),
+	UCCP_DEBUG_80211IF		= BIT(6),
+	UCCP_DEBUG_RX			= BIT(7),
+	UCCP_DEBUG_HAL			= BIT(8),
+	UCCP_DEBUG_CRYPTO		= BIT(9),
+	UCCP_DEBUG_DUMP_RX		= BIT(10),
+	UCCP_DEBUG_DUMP_HAL		= BIT(11),
+	UCCP_DEBUG_TSMC			= BIT(12),
 };
 
 struct wifi_sync {
@@ -226,7 +248,6 @@ struct wifi_params {
 	/*RF Params: Input to the RF for operation*/
 	unsigned char  rf_params[RF_PARAMS_SIZE];
 	unsigned char  rf_params_vpd[RF_PARAMS_SIZE];
-	/*Calibration Params: Input for different calibrations in RF*/
 	unsigned char production_test;
 	unsigned int dot11a_support;
 	unsigned int dot11g_support;
@@ -234,6 +255,16 @@ struct wifi_params {
 	unsigned int prod_mode_chnl_bw_40_mhz;
 	unsigned int sec_ch_offset_40_plus;
 	unsigned int sec_ch_offset_40_minus;
+
+	/*Multicast  Rate config options*/
+	unsigned int mgd_mode_mcast_fixed_rate_flags;
+	int mgd_mode_mcast_fixed_data_rate;
+	unsigned int mgd_mode_mcast_fixed_bcc_or_ldpc;
+	unsigned int mgd_mode_mcast_fixed_stbc_enabled;
+	unsigned int mgd_mode_mcast_fixed_preamble;
+	unsigned char mgd_mode_mcast_fixed_nss;
+	/*End*/
+
 	unsigned int prod_mode_rate_flag;
 	unsigned int prod_mode_rate_preamble_type;
 	unsigned int prod_mode_stbc_enabled;
@@ -495,6 +526,7 @@ struct tx_pkt_info {
 	unsigned int curr_retries;
 	unsigned int max_retries;
 	int roc_peer_id;
+	int peer_id;
 	bool adjusted_rates;
 };
 
@@ -620,6 +652,7 @@ struct mac80211_dev {
 	char cancel_roc;
 	char chan_prog_done;
 	char reset_complete;
+	char tx_deinit_complete;
 	int power_save; /* Will be set only when a single VIF in
 			 * STA mode is active
 			 */
@@ -718,6 +751,7 @@ extern int wait_for_scan_abort(struct mac80211_dev *dev);
 extern int wait_for_channel_prog_complete(struct mac80211_dev *dev);
 extern int wait_for_tx_queue_flush_complete(struct mac80211_dev *dev,
 					    unsigned int token);
+int wait_for_tx_deinit_complete(struct mac80211_dev *dev);
 extern int uccp420wlan_prog_nw_selection(unsigned int nw_select_enabled,
 					 unsigned char *mac_addr);
 extern int  uccp420wlan_core_init(struct mac80211_dev *dev, unsigned int ftm);
@@ -774,8 +808,19 @@ int uccp420_flush_vif_queues(struct mac80211_dev *dev,
 			     struct umac_vif *uvif,
 			     int chanctx_idx,
 			     unsigned int hw_queue_map,
-			     enum UMAC_VIF_CHANCTX_TYPE vif_chanctx_type);
-
+			     enum UMAC_VIF_CHANCTX_TYPE vif_chanctx_type,
+			     bool drop);
+
+int uccp420_discard_sta_pend_q(struct mac80211_dev *dev,
+				   struct umac_vif *uvif,
+				   int peer_id,
+				   unsigned int hw_queue_map);
+
+int uccp420_discard_sta_tx_q(struct mac80211_dev *dev,
+				   struct umac_vif *uvif,
+				   int peer_id,
+				   unsigned int hw_queue_map,
+				   int chanctx_idx);
 /* Beacon TimeStamp */
 __s32 __attribute__((weak)) frc_to_atu(__u32 frccnt, __u64 *patu, s32 dir);
 int __attribute__((weak)) get_evt_timer_freq(unsigned int *mask,
@@ -844,6 +889,129 @@ static __always_inline long param_get_match(unsigned char *buf,
 		return 0;
 }
 
+static __always_inline char *get_string_from_rate(int rate,
+						   unsigned int flags)
+{
+	if (rate == -1)
+		return "Disabled";
+
+	if (flags & ENABLE_VHT_FORMAT)
+		return "VHT";
+
+	if (flags & ENABLE_11N_FORMAT)
+		return "HT";
+
+	return "Legacy";
+}
+
+static __always_inline bool check_valid_rate_flags(struct mac80211_dev *dev,
+						   unsigned long val)
+{
+	bool ret = false;
+
+	do {
+		/*Only first 6 flags are defined currently*/
+		if (val > 63) {
+			pr_err("Invalid parameter value");
+			break;
+		}
+
+		if ((val & ENABLE_VHT_FORMAT) &&
+		    (val & ENABLE_11N_FORMAT)) {
+			pr_err("Cannot set HT and VHT both.");
+			break;
+		}
+
+		if ((val & ENABLE_CHNL_WIDTH_40MHZ) &&
+		    (val & ENABLE_CHNL_WIDTH_80MHZ)) {
+			pr_err("Cannot set 40 and 80 both.");
+			break;
+		}
+
+		if ((dev->params->uccp_num_spatial_streams == 1)  &&
+		    (val & ENABLE_SGI) &&
+		    (val & ENABLE_GREEN_FIELD)) {
+			pr_err("Cannot set GreenField when SGI is enabled for SISO");
+			break;
+		}
+		ret = true;
+	} while (0);
+
+	return ret;
+}
+
+static __always_inline bool check_valid_data_rate(struct mac80211_dev *dev,
+						  int dr,
+						  enum ptype type)
+{
+	bool is_mcs = dr & 0x80;
+	bool ret = false;
+	unsigned int rate;
+	unsigned int nss;
+
+	if (type == UCAST) {
+		rate = dev->params->prod_mode_rate_flag;
+		nss  = dev->params->num_spatial_streams;
+	} else {
+		rate = dev->params->mgd_mode_mcast_fixed_rate_flags;
+		nss  = dev->params->mgd_mode_mcast_fixed_nss;
+	}
+
+	if (dr == -1)
+		return true;
+
+	if (is_mcs) {
+		dr = dr & 0x7F;
+		if (vht_support && (rate &
+				    ENABLE_VHT_FORMAT)) {
+			if ((dr >= 0 && dr <= 9))
+				ret = true;
+			else
+				pr_err("Invalid VHT MCS value: %d\n", dr);
+		} else if (rate & ENABLE_11N_FORMAT) {
+			if (nss == 2) {
+				if ((dr >= 8) && (dr <= 15))
+					ret = true;
+				else
+					pr_err("Invalid MIMO HT MCS: %d\n",
+					       dr);
+			}
+			if (nss == 1) {
+				if ((dr >= 0) && (dr <= 7))
+					ret = true;
+				else
+					pr_err("Invalid SISO HT MCS: %d\n",
+					       dr);
+			}
+		}
+
+	} else {
+		if (dev->params->dot11g_support == 1 &&
+		    ((dr == 1) ||
+		     (dr == 2) ||
+		     (dr == 55) ||
+		     (dr == 11))) {
+			ret = true;
+		} else if ((dr == 6) ||
+			   (dr == 9) ||
+			   (dr == 12) ||
+			   (dr == 18) ||
+			   (dr == 24) ||
+			   (dr == 36) ||
+			   (dr == 48) ||
+			   (dr == 54) ||
+			   (dr == -1)) {
+			ret = true;
+		} else
+			pr_err("Invalid Legacy Rate value: %d\n", dr);
+		if ((rate & ENABLE_11N_FORMAT) || (rate & ENABLE_VHT_FORMAT)) {
+			ret = false;
+			pr_err("Invalid rate_flags for legacy: %d\n", dr);
+		}
+	}
+	return ret;
+}
+
 static inline int vif_addr_to_index(unsigned char *addr,
 				    struct mac80211_dev *dev)
 {
diff --git a/drivers/net/wireless/uccp420wlan/inc/fwldr.h b/drivers/net/wireless/uccp420wlan/inc/fwldr.h
index cee1bca..f643da7 100644
--- a/drivers/net/wireless/uccp420wlan/inc/fwldr.h
+++ b/drivers/net/wireless/uccp420wlan/inc/fwldr.h
@@ -25,8 +25,9 @@
 #ifndef _FWLDR_H_
 #define _FWLDR_H_
 
-#include <linux/skbuff.h>
 #include <linux/interrupt.h>
+#include <linux/skbuff.h>
+
 #include "hal.h"
 #include "version.h"
 
diff --git a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
index 01f2b39..cf06daf 100644
--- a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
+++ b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
@@ -26,6 +26,7 @@
 #define _UCCP420HOST_UMAC_IF_H_
 
 #include "hal.h"
+
 #define MCST_ADDR_LIMIT	48
 #define WLAN_ADDR_LEN 6
 #define TKIP_MIC_LEN 8
@@ -415,6 +416,7 @@ enum UMAC_CMD_TAG {
 	UMAC_CMD_CHANCTX_TIME_INFO,
 #endif
 	UMAC_CMD_CONT_TX,
+	UMAC_CMD_TX_DEINIT,
 };
 
 enum UMAC_EVENT_TAG {
@@ -448,6 +450,7 @@ enum UMAC_EVENT_TAG {
 	UMAC_EVENT_CHAN_SWITCH,
 #endif
 	UMAC_EVENT_FW_ERROR,
+	UMAC_EVENT_TX_DEINIT_DONE,
 };
 
 enum CONNECT_RESULT_TAG {
@@ -1003,6 +1006,12 @@ struct cmd_chanctx_time_config {
 } __packed;
 #endif
 
+struct cmd_tx_deinit {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned char peer_addr[ETH_ALEN];
+} __packed;
+
 /* Events */
 
 struct nw_found_event {
@@ -1157,4 +1166,14 @@ struct umac_event_roc_status {
 	unsigned int roc_status;
 } __packed;
 
+enum TX_DEINIT_DONE_STATUS {
+	TX_DEINIT_DONE_SUCCESS = 0,
+	TX_DEINIT_DONE_FAIL,
+};
+
+struct umac_event_tx_deinit_done {
+	struct host_mac_msg_hdr hdr;
+	enum TX_DEINIT_DONE_STATUS status;
+} __packed;
+
 #endif /*_UCCP420HOST_UMAC_IF_H_*/
diff --git a/drivers/net/wireless/uccp420wlan/inc/umac_if.h b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
index 36de891..38c13e0 100644
--- a/drivers/net/wireless/uccp420wlan/inc/umac_if.h
+++ b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
@@ -29,7 +29,9 @@
 
 #ifndef _UCCP420WLAN_UMAC_IF_H_
 #define _UCCP420WLAN_UMAC_IF_H_
+
 #include <linux/skbuff.h>
+
 #include "hal.h"
 #include "host_umac_if.h"
 
@@ -300,6 +302,7 @@ extern void uccp420_lmac_if_free_outstnding(void);
 extern int uccp420wlan_prog_chanctx_time_info(void);
 #endif
 
+extern int uccp420wlan_prog_tx_deinit(int vif_index, char *peer_addr);
 #endif /* _UCCP420WLAN_UMAC_IF_H_ */
 
 /* EOF */
diff --git a/drivers/net/wireless/uccp420wlan/inc/version.h b/drivers/net/wireless/uccp420wlan/inc/version.h
index b173a54..1a24b91 100644
--- a/drivers/net/wireless/uccp420wlan/inc/version.h
+++ b/drivers/net/wireless/uccp420wlan/inc/version.h
@@ -23,7 +23,7 @@
  */
 #ifndef _UCCP420WLAN_VERSION_H
 #define _UCCP420WLAN_VERSION_H
-#define UCCP_DRIVER_VERSION "6_0_4"
+#define UCCP_DRIVER_VERSION "6_0_5"
 #define UCCP_DRIVER_NAME "UCCP420WIFI"
 #endif /* _UCCP420WLAN_VERSION_H */
 
diff --git a/drivers/net/wireless/uccp420wlan/src/80211_if.c b/drivers/net/wireless/uccp420wlan/src/80211_if.c
index 2239c75..5ce61b7 100644
--- a/drivers/net/wireless/uccp420wlan/src/80211_if.c
+++ b/drivers/net/wireless/uccp420wlan/src/80211_if.c
@@ -22,40 +22,39 @@
  * USA.
  */
 
+#include <linux/device.h>
+#include <linux/etherdevice.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/ip.h>
 #include <linux/kernel.h>
 #include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/udp.h>
 #include <linux/version.h>
-#include <linux/device.h>
 
-#include <net/mac80211.h>
 #include <net/cfg80211.h>
 #include <net/ieee80211_radiotap.h>
+#include <net/mac80211.h>
 
-#include <linux/udp.h>
-#include <linux/ip.h>
-#include <linux/etherdevice.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/proc_fs.h>
-
-#include "version.h"
 #include "core.h"
+#include "fwldr.h"
 #include "utils.h"
+#include "version.h"
 
-#include <linux/firmware.h>
 
-#include <fwldr.h>
 
-#define UCCP_DEBUG_80211IF(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_80211IF)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_80211IF(fmt, ...)        \
+do {                                         \
+	if (uccp_debug & UCCP_DEBUG_80211IF)  \
+		pr_debug(fmt, ##__VA_ARGS__);  \
 } while (0)
 
-#define UCCP_DEBUG_CRYPTO(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_CRYPTO)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_CRYPTO(fmt, ...)           \
+do {                                           \
+	if (uccp_debug & UCCP_DEBUG_CRYPTO)     \
+		pr_debug(fmt, ##__VA_ARGS__);    \
 } while (0)
 
 /* Its value will be the default mac address and it can only be updated with the
@@ -351,6 +350,9 @@ static void uccp420_roc_complete_work(struct work_struct *work)
 	dev = container_of(dwork, struct mac80211_dev, roc_complete_work);
 	tx = &dev->tx;
 
+	if (dev->roc_params.roc_in_progress == 0)
+		return;
+
 	mutex_lock(&dev->mutex);
 #ifdef MULTI_CHAN_SUPPORT
 	need_offchan = dev->roc_params.need_offchan;
@@ -381,7 +383,8 @@ static void uccp420_roc_complete_work(struct work_struct *work)
 					 uvif,
 					 uvif->off_chanctx->index,
 					 BIT(UMAC_ROC_AC),
-					 UMAC_VIF_CHANCTX_TYPE_OFF);
+					 UMAC_VIF_CHANCTX_TYPE_OFF,
+					 TX_DROP);
 
 
 		spin_lock_bh(&tx->lock);
@@ -689,6 +692,7 @@ static int config(struct ieee80211_hw *hw,
 	int i = 0;
 	int err = 0;
 	struct ieee80211_vif *vif = NULL;
+	int ret = 0;
 
 	UCCP_DEBUG_80211IF("%s-80211IF:In config\n", dev->name);
 
@@ -696,7 +700,7 @@ static int config(struct ieee80211_hw *hw,
 
 	if (changed & IEEE80211_CONF_CHANGE_POWER) {
 		dev->txpower = conf->power_level;
-		uccp420wlan_prog_txpower(dev->txpower);
+		CALL_UMAC(uccp420wlan_prog_txpower, dev->txpower);
 	}
 
 	/* Check for change in channel */
@@ -730,7 +734,8 @@ static int config(struct ieee80211_hw *hw,
 					   pri_chnl_num,
 					   ch_width);
 
-			uccp420wlan_prog_radar_detect(RADAR_DETECT_OP_START);
+			CALL_UMAC(uccp420wlan_prog_radar_detect,
+				  RADAR_DETECT_OP_START);
 		}
 	}
 
@@ -821,8 +826,9 @@ static int config(struct ieee80211_hw *hw,
 					    conf->long_frame_max_tx_count);
 	}
 
+prog_umac_fail:
 	mutex_unlock(&dev->mutex);
-	return 0;
+	return ret;
 }
 
 
@@ -833,6 +839,7 @@ static u64 prepare_multicast(struct ieee80211_hw *hw,
 	int i;
 	struct netdev_hw_addr *ha;
 	int mc_count = 0;
+	int ret = 0;
 
 	if (dev->state != STARTED)
 		return 0;
@@ -861,7 +868,9 @@ static u64 prepare_multicast(struct ieee80211_hw *hw,
 
 	netdev_hw_addr_list_for_each(ha, mc_list) {
 		/* Prog the multicast address into the LMAC */
-		uccp420wlan_prog_mcast_addr_cfg(ha->addr, WLAN_MCAST_ADDR_ADD);
+		CALL_UMAC(uccp420wlan_prog_mcast_addr_cfg,
+			  ha->addr,
+			  WLAN_MCAST_ADDR_ADD);
 		memcpy(dev->mc_filters[i], ha->addr, 6);
 		i++;
 	}
@@ -869,6 +878,8 @@ static u64 prepare_multicast(struct ieee80211_hw *hw,
 	dev->mc_filter_count = mc_count;
 out:
 	return mc_count;
+prog_umac_fail:
+	return ret;
 }
 
 
@@ -878,6 +889,7 @@ static void configure_filter(struct ieee80211_hw *hw,
 		u64 mc_count)
 {
 	struct mac80211_dev *dev = hw->priv;
+	int ret = 0;
 
 	mutex_lock(&dev->mutex);
 
@@ -892,13 +904,15 @@ static void configure_filter(struct ieee80211_hw *hw,
 	if ((*new_flags & FIF_ALLMULTI) || (mc_count == 0)) {
 		/* Disable the multicast filter in LMAC */
 		UCCP_DEBUG_80211IF("%s-80211IF: Multicast filters disabled\n",
-			       dev->name);
-		uccp420wlan_prog_mcast_filter_control(MCAST_FILTER_DISABLE);
+				   dev->name);
+		CALL_UMAC(uccp420wlan_prog_mcast_filter_control,
+			  MCAST_FILTER_DISABLE);
 	} else if (mc_count) {
 		/* Enable the multicast filter in LMAC */
 		UCCP_DEBUG_80211IF("%s-80211IF: Multicast filters enabled\n",
 			       dev->name);
-		uccp420wlan_prog_mcast_filter_control(MCAST_FILTER_ENABLE);
+		CALL_UMAC(uccp420wlan_prog_mcast_filter_control,
+			  MCAST_FILTER_ENABLE);
 	}
 
 	if (changed_flags == 0)
@@ -910,20 +924,22 @@ static void configure_filter(struct ieee80211_hw *hw,
 			/* Receive all beacons and probe responses */
 			UCCP_DEBUG_80211IF("%s-80211IF: RCV ALL bcns\n",
 				       dev->name);
-			uccp420wlan_prog_rcv_bcn_mode(RCV_ALL_BCNS);
+			CALL_UMAC(uccp420wlan_prog_rcv_bcn_mode, RCV_ALL_BCNS);
 		} else {
 			/* Receive only network beacons and probe responses */
 			UCCP_DEBUG_80211IF("%s-80211IF: RCV NW bcns\n",
-				       dev->name);
-			uccp420wlan_prog_rcv_bcn_mode(RCV_ALL_NETWORK_ONLY);
+					   dev->name);
+			CALL_UMAC(uccp420wlan_prog_rcv_bcn_mode,
+				  RCV_ALL_NETWORK_ONLY);
 		}
 	}
 out:
 	if (wifi->params.production_test == 1) {
 		UCCP_DEBUG_80211IF("%s-80211IF: RCV ALL bcns\n", dev->name);
-		uccp420wlan_prog_rcv_bcn_mode(RCV_ALL_BCNS);
+		CALL_UMAC(uccp420wlan_prog_rcv_bcn_mode, RCV_ALL_BCNS);
 	}
 
+prog_umac_fail:
 	mutex_unlock(&dev->mutex);
 }
 
@@ -1385,6 +1401,7 @@ static void init_hw(struct ieee80211_hw *hw)
 	ieee80211_hw_set(hw, SUPPORTS_PER_STA_GTK);
 	ieee80211_hw_set(hw, CONNECTION_MONITOR);
 	ieee80211_hw_set(hw, CHANCTX_STA_CSA);
+	ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
 
 	hw->wiphy->max_scan_ssids = MAX_NUM_SSIDS; /* 4 */
 	 /* Low priority bg scan */
@@ -1550,6 +1567,7 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 	struct ieee80211_chanctx_conf *vif_chanctx;
 	bool need_offchan = true;
 #endif
+	int ret = 0;
 
 	mutex_lock(&dev->mutex);
 	UCCP_DEBUG_ROC("%s:%d The Params are:",
@@ -1646,7 +1664,8 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 					uvif,
 					uvif->chanctx->index,
 					hw_queue_map,
-					UMAC_VIF_CHANCTX_TYPE_OPER);
+					UMAC_VIF_CHANCTX_TYPE_OPER,
+					TX_FLUSH);
 		}
 
 
@@ -1692,17 +1711,20 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 	uvif->off_chanctx = off_chanctx;
 	spin_unlock_bh(&tx->lock);
 #endif
-
-	uccp420wlan_prog_roc(ROC_START, pri_chnl_num, duration, type);
+	CALL_UMAC(uccp420wlan_prog_roc,
+		  ROC_START,
+		  pri_chnl_num,
+		  duration,
+		  type);
 
 #ifdef MULTI_CHAN_SUPPORT
 	if (uvif->chanctx)
 		ieee80211_wake_queues(hw);
 #endif
 
+prog_umac_fail:
 	mutex_unlock(&dev->mutex);
-
-	return 0;
+	return ret;
 }
 
 
@@ -1718,7 +1740,7 @@ static int cancel_remain_on_channel(struct ieee80211_hw *hw)
 		dev->cancel_roc = 1;
 		UCCP_DEBUG_ROC("%s:%d Cancelling HW ROC....\n",
 				__func__, __LINE__);
-		uccp420wlan_prog_roc(ROC_STOP, 0, 0, 0);
+		CALL_UMAC(uccp420wlan_prog_roc, ROC_STOP, 0, 0, 0);
 
 		mutex_unlock(&dev->mutex);
 
@@ -1733,10 +1755,9 @@ static int cancel_remain_on_channel(struct ieee80211_hw *hw)
 							__LINE__);
 			ret = -1;
 		}
-	} else {
-		mutex_unlock(&dev->mutex);
 	}
-
+prog_umac_fail:
+	mutex_unlock(&dev->mutex);
 	return ret;
 }
 
@@ -2129,10 +2150,36 @@ int sta_remove(struct ieee80211_hw *hw,
 	int result = 0;
 	struct mac80211_dev *dev = hw->priv;
 	struct umac_sta *usta = (struct umac_sta *)sta->drv_priv;
+	struct tx_config *tx = &dev->tx;
+	u32 hw_queue_map = 0;
 
 	for (i = 0; i < ETH_ALEN; i++)
 		peer_st_info.addr[i] = sta->addr[i];
 
+	/*purge the queues*/
+
+	for (i = 0; i < NUM_ACS; i++)
+		hw_queue_map |= BIT(i);
+
+	spin_lock_bh(&tx->lock);
+	UCCP_DEBUG_TX("%s:%d discard tx\n", __func__, __LINE__);
+	uccp420_discard_sta_pend_q(dev, uvif, usta->index, hw_queue_map);
+	spin_unlock_bh(&tx->lock);
+	dev->tx_deinit_complete = 0;
+	uccp420wlan_prog_tx_deinit(usta->vif_index, sta->addr);
+
+	if (wait_for_tx_deinit_complete(dev) < 0) {
+		WARN_ON(1);
+		spin_lock_bh(&tx->lock);
+		UCCP_DEBUG_TX("%s:%d discarding\n", __func__, __LINE__);
+		uccp420_discard_sta_tx_q(dev,
+					 uvif,
+					 usta->index,
+					 hw_queue_map,
+					 usta->chanctx->index);
+		spin_unlock_bh(&tx->lock);
+	}
+
 	result = uccp420wlan_sta_remove(uvif->vif_index, &peer_st_info);
 
 	if (!result) {
@@ -2291,9 +2338,10 @@ static int rpu_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *skb,
 
 	curr_dump = ((char *)dump_start) + (MAX_NL_DUMP_LEN * idx);
 
-	if (!curr_dump  || (curr_dump < (char *)dump_start) ||
-		(curr_dump > ((char *)dump_start + dump_len)))
-			goto dump_fail;
+	if (!curr_dump  ||
+	    (curr_dump < (char *)dump_start) ||
+	    (curr_dump > ((char *)dump_start + dump_len)))
+		goto dump_fail;
 
 	if (curr_msg_len > skb_tailroom(skb))
 		goto dump_fail;
@@ -2361,7 +2409,7 @@ static int add_chanctx(struct ieee80211_hw *hw,
 
 	dev = hw->priv;
 
-	UCCP_DEBUG_TSMC("GOT add chanctx\n");
+	UCCP_DEBUG_80211IF("GOT add chanctx\n");
 
 	for (i = 0; i < MAX_CHANCTX; i++) {
 		if (!dev->chanctx[i]) {
@@ -2375,7 +2423,7 @@ static int add_chanctx(struct ieee80211_hw *hw,
 		return -1;
 	}
 
-	UCCP_DEBUG_TSMC("%s: %d MHz\n",
+	UCCP_DEBUG_80211IF("%s: %d MHz\n",
 			__func__,
 			conf->def.chan->center_freq);
 
@@ -2402,9 +2450,9 @@ static void remove_chanctx(struct ieee80211_hw *hw,
 
 	dev = hw->priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
-	UCCP_DEBUG_TSMC("GOT remove chanctx\n");
+	UCCP_DEBUG_80211IF("GOT remove chanctx\n");
 
-	UCCP_DEBUG_TSMC("%s: %d MHz\n",
+	UCCP_DEBUG_80211IF("%s: %d MHz\n",
 					 __func__,
 					 conf->def.chan->center_freq);
 
@@ -2433,18 +2481,20 @@ static void change_chanctx(struct ieee80211_hw *hw,
 	int i = 0;
 	int center_freq = 0;
 	int chan = 0;
-	int err = 0;
+	int err = 0, ret = 0;
 
 	dev = hw->priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
 
-	UCCP_DEBUG_TSMC("Got change_chanctx: %d\n", changed);
-	pr_err("%s: %d MHz\n", __func__, conf->def.chan->center_freq);
+	UCCP_DEBUG_80211IF("Got change_chanctx: %d\n", changed);
+	UCCP_DEBUG_80211IF("%s: %d MHz\n", __func__,
+			   conf->def.chan->center_freq);
 
 	if (changed & IEEE80211_CHANCTX_CHANGE_WIDTH ||
 	    changed & IEEE80211_CHANCTX_CHANGE_CHANNEL) {
-		pr_err("%s channel width = %d channel = %d\n", __func__,
-				conf->def.width, conf->def.center_freq1);
+		UCCP_DEBUG_80211IF("%s channel width = %d channel = %d\n",
+				   __func__,
+				   conf->def.width, conf->def.center_freq1);
 
 		center_freq = conf->def.chan->center_freq;
 		chan = ieee80211_frequency_to_channel(center_freq);
@@ -2461,7 +2511,7 @@ static void change_chanctx(struct ieee80211_hw *hw,
 	}
 
 	if (changed & IEEE80211_CHANCTX_CHANGE_MIN_WIDTH) {
-		UCCP_DEBUG_TSMC("%s Minimum channel width = %d\n", __func__,
+		UCCP_DEBUG_80211IF("%s Minimum channel width = %d\n", __func__,
 			conf->min_def.width);
 
 		center_freq = conf->min_def.chan->center_freq;
@@ -2482,9 +2532,10 @@ static void change_chanctx(struct ieee80211_hw *hw,
 
 	/* TODO: Make this global config as it effects all VIF's */
 	if (changed & IEEE80211_CHANCTX_CHANGE_RX_CHAINS) {
-		UCCP_DEBUG_TSMC("%s rx_chains_static=%d rx_chains_dynamic=%d\n",
-			__func__, conf->rx_chains_static,
-			conf->rx_chains_dynamic);
+		UCCP_DEBUG_80211IF("%s rx_chains static=%d dynamic=%d\n",
+				   __func__,
+				   conf->rx_chains_static,
+				   conf->rx_chains_dynamic);
 
 		list_for_each_entry(uvif, &ctx->vifs, list) {
 			for (i = 0; i < MAX_VIFS; i++) {
@@ -2518,10 +2569,14 @@ static void change_chanctx(struct ieee80211_hw *hw,
 				   conf->radar_enabled);
 
 		if (conf->radar_enabled)
-			uccp420wlan_prog_radar_detect(RADAR_DETECT_OP_START);
+			CALL_UMAC(uccp420wlan_prog_radar_detect,
+				  RADAR_DETECT_OP_START);
 		else
-			uccp420wlan_prog_radar_detect(RADAR_DETECT_OP_STOP);
+			CALL_UMAC(uccp420wlan_prog_radar_detect,
+				  RADAR_DETECT_OP_STOP);
 	}
+prog_umac_fail:
+	return;
 }
 
 
@@ -2533,12 +2588,12 @@ static int assign_vif_chanctx(struct ieee80211_hw *hw,
 	struct umac_vif *uvif = NULL;
 	struct umac_chanctx *ctx = NULL;
 	int prog_chanctx_time_info = 0;
-	int err = 0;
+	int ret = 0;
 
 	dev = hw->priv;
 	uvif = (struct umac_vif *)vif->drv_priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
-	UCCP_DEBUG_TSMC("Got assign_vif_chanctx\n");
+	UCCP_DEBUG_80211IF("Got assign_vif_chanctx\n");
 
 	DEBUG_LOG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
 		  __func__,
@@ -2563,14 +2618,14 @@ static int assign_vif_chanctx(struct ieee80211_hw *hw,
 			dev->curr_chanctx_idx = ctx->index;
 
 		dev->num_active_chanctx++;
-		uccp420wlan_prog_chanctx_time_info();
+		CALL_UMAC(uccp420wlan_prog_chanctx_time_info);
 	}
 
-	err = umac_chanctx_set_channel(dev, uvif, &conf->def);
+	ret = umac_chanctx_set_channel(dev, uvif, &conf->def);
 
+prog_umac_fail:
 	mutex_unlock(&dev->mutex);
-
-	return err;
+	return ret;
 }
 
 
@@ -2582,13 +2637,13 @@ static void unassign_vif_chanctx(struct ieee80211_hw *hw,
 	struct umac_vif *uvif = NULL;
 	struct umac_chanctx *ctx = NULL;
 	u32 hw_queue_map = 0;
-	int i = 0;
+	int i = 0, ret = 0;
 
 	dev = hw->priv;
 	uvif = (struct umac_vif *)vif->drv_priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
 
-	UCCP_DEBUG_TSMC("Got unassign_vif_chanctx\n");
+	UCCP_DEBUG_80211IF("Got unassign_vif_chanctx\n");
 
 	DEBUG_LOG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
 		  __func__,
@@ -2607,11 +2662,15 @@ static void unassign_vif_chanctx(struct ieee80211_hw *hw,
 		for (i = 0; i < NUM_ACS; i++)
 			hw_queue_map |= BIT(i);
 
+		ieee80211_stop_queues(hw);
 		uccp420_flush_vif_queues(dev,
 					 uvif,
 					 uvif->chanctx->index,
 					 hw_queue_map,
-					 UMAC_VIF_CHANCTX_TYPE_OPER);
+					 UMAC_VIF_CHANCTX_TYPE_OPER,
+					 TX_DROP);
+
+		ieee80211_wake_queues(hw);
 	}
 
 	uvif->chanctx = NULL;
@@ -2623,9 +2682,10 @@ static void unassign_vif_chanctx(struct ieee80211_hw *hw,
 		dev->num_active_chanctx--;
 
 		if (dev->num_active_chanctx)
-			uccp420wlan_prog_chanctx_time_info();
+			CALL_UMAC(uccp420wlan_prog_chanctx_time_info);
 	}
 
+prog_umac_fail:
 	mutex_unlock(&dev->mutex);
 }
 
@@ -2638,14 +2698,14 @@ static int switch_vif_chanctx(struct ieee80211_hw *hw,
 	struct mac80211_dev *dev = NULL;
 	int ret = 0;
 
-	UCCP_DEBUG_TSMC("Got switch_vif_chanctx\n");
+	UCCP_DEBUG_80211IF("Got switch_vif_chanctx\n");
 	dev = hw->priv;
 
 	/*TODO*/
 	if (n_vifs > 1)
 		return -EOPNOTSUPP;
 
-	pr_err("%s switch_vif_chanctx switch freq %hu->%hu width %d->%d\n",
+	UCCP_DEBUG_80211IF("%s switch freq %hu->%hu width %d->%d\n",
 		 __func__,
 		vifs[0].old_ctx->def.chan->center_freq,
 		vifs[0].new_ctx->def.chan->center_freq,
@@ -2707,7 +2767,8 @@ static void flush_queues(struct ieee80211_hw *hw,
 				 uvif,
 				 uvif->chanctx->index,
 				 hw_queue_map,
-				 UMAC_VIF_CHANCTX_TYPE_OPER);
+				 UMAC_VIF_CHANCTX_TYPE_OPER,
+				 drop ? TX_DROP : TX_FLUSH);
 
 out:
 	mutex_unlock(&dev->mutex);
@@ -2925,7 +2986,14 @@ static int proc_read_config(struct seq_file *m, void *v)
 	int cnt = 0;
 	int rf_params_size = sizeof(wifi->params.rf_params) /
 			     sizeof(wifi->params.rf_params[0]);
-	struct mac80211_dev *dev = ((struct mac80211_dev *)(wifi->hw->priv));
+	struct mac80211_dev *dev;
+	unsigned int nss, flags;
+	int mcs;
+
+	if (!wifi->hw)
+		return -ENODEV;
+
+	dev = ((struct mac80211_dev *)(wifi->hw->priv));
 
 	seq_puts(m, "************* Configurable Parameters ***********\n");
 	seq_printf(m, "dot11g_support = %d\n", wifi->params.dot11g_support);
@@ -2947,23 +3015,6 @@ static int proc_read_config(struct seq_file *m, void *v)
 
 	seq_printf(m, "production_test = %d\n", wifi->params.production_test);
 	seq_printf(m, "bypass_vpd = %d\n", wifi->params.bypass_vpd);
-	seq_printf(m, "tx_fixed_mcs_indx = %d (%s)\n",
-		   wifi->params.tx_fixed_mcs_indx,
-		   (wifi->params.prod_mode_rate_flag &
-		    ENABLE_VHT_FORMAT) ?
-		   "VHT" : (wifi->params.prod_mode_rate_flag &
-			    ENABLE_11N_FORMAT) ? "HT" : "Not Set");
-	if (wifi->params.tx_fixed_rate > -1) {
-		if (wifi->params.tx_fixed_rate == 55)
-			seq_puts(m, "tx_fixed_rate = 5.5\n");
-		else
-			seq_printf(m, "tx_fixed_rate = %d\n",
-				   wifi->params.tx_fixed_rate);
-	} else
-		seq_printf(m, "tx_fixed_rate = %d\n",
-			   wifi->params.tx_fixed_rate);
-	seq_printf(m, "num_spatial_streams (Per Frame) = %d\n",
-		   wifi->params.num_spatial_streams);
 	seq_printf(m, "uccp_num_spatial_streams (UCCP Init) = %d\n",
 		   wifi->params.uccp_num_spatial_streams);
 	seq_printf(m, "enable_early_agg_checks = %d\n",
@@ -2979,21 +3030,6 @@ static int proc_read_config(struct seq_file *m, void *v)
 		   wifi->params.disable_power_save);
 	seq_printf(m, "disable_sm_power_save (Disables MIMO PS only) = %d\n",
 		   wifi->params.disable_sm_power_save);
-	seq_printf(m, "mgd_mode_tx_fixed_mcs_indx = %d (%s)\n",
-		   wifi->params.mgd_mode_tx_fixed_mcs_indx,
-		   (wifi->params.prod_mode_rate_flag &
-		    ENABLE_VHT_FORMAT) ?
-		   "VHT" : (wifi->params.prod_mode_rate_flag &
-			    ENABLE_11N_FORMAT) ? "HT" : "Not Set");
-	if (wifi->params.mgd_mode_tx_fixed_rate > -1) {
-		if (wifi->params.mgd_mode_tx_fixed_rate == 55)
-			seq_puts(m, "mgd_mode_tx_fixed_rate = 5.5\n");
-		else
-			seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
-				   wifi->params.mgd_mode_tx_fixed_rate);
-	} else
-		seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
-			   wifi->params.mgd_mode_tx_fixed_rate);
 
 	seq_printf(m, "num_vifs = %d\n",
 		   wifi->params.num_vifs);
@@ -3019,6 +3055,43 @@ static int proc_read_config(struct seq_file *m, void *v)
 	}
 	seq_printf(m, "rate_protection_type = %d (0: Disable, 1: Enable)\n",
 		   wifi->params.rate_protection_type);
+	if (wifi->params.production_test) {
+		mcs = wifi->params.tx_fixed_mcs_indx;
+		flags = wifi->params.prod_mode_rate_flag;
+		seq_puts(m, "***Production Mode Rate config options\n");
+		seq_printf(m, "tx_fixed_mcs_indx = %d (%s)\n",
+			   mcs, get_string_from_rate(mcs, flags));
+		if (wifi->params.tx_fixed_rate > -1) {
+			if (wifi->params.tx_fixed_rate == 55)
+				seq_puts(m, "tx_fixed_rate = 5.5\n");
+			else
+				seq_printf(m, "tx_fixed_rate = %d\n",
+					   wifi->params.tx_fixed_rate);
+		} else
+			seq_printf(m, "tx_fixed_rate = %d\n",
+				   wifi->params.tx_fixed_rate);
+	} else {
+		seq_puts(m, "***Unicast Fixed rate config options\n");
+		mcs = wifi->params.mgd_mode_tx_fixed_mcs_indx;
+		flags = wifi->params.prod_mode_rate_flag;
+		seq_printf(m, "mgd_mode_tx_fixed_mcs_indx = %d (%s)\n",
+			   mcs, get_string_from_rate(mcs, flags));
+		if (wifi->params.mgd_mode_tx_fixed_rate > -1) {
+			if (wifi->params.mgd_mode_tx_fixed_rate == 55)
+				seq_puts(m, "mgd_mode_tx_fixed_rate = 5.5\n");
+			else
+				seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
+					   wifi->params.mgd_mode_tx_fixed_rate);
+		} else
+			seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
+				   wifi->params.mgd_mode_tx_fixed_rate);
+	}
+
+	if (wifi->params.prod_mode_rate_flag & ENABLE_11N_FORMAT)
+		nss = wifi->params.mgd_mode_tx_fixed_mcs_indx/8 + 1;
+	else
+		nss = wifi->params.num_spatial_streams;
+
 	seq_puts(m, "Bits:80MHz-VHT-11N-SGI-40MHz-GF\n");
 	seq_printf(m, "prod_mode_rate_flag = %d\n",
 		   wifi->params.prod_mode_rate_flag);
@@ -3028,6 +3101,36 @@ static int proc_read_config(struct seq_file *m, void *v)
 		   wifi->params.prod_mode_stbc_enabled);
 	seq_printf(m, "prod_mode_bcc_or_ldpc = %d\n",
 		   wifi->params.prod_mode_bcc_or_ldpc);
+	seq_printf(m, "num_spatial_streams = %d\n", nss);
+
+	seq_puts(m, "***Multicast Fixed rate config options\n");
+
+	mcs = wifi->params.mgd_mode_mcast_fixed_data_rate;
+	flags = wifi->params.mgd_mode_mcast_fixed_rate_flags;
+	if ((mcs != -1) && (mcs & 0x80))
+		mcs = mcs & 0x7F;
+
+	if (flags & ENABLE_11N_FORMAT)
+		nss = mcs/8 + 1;
+	else
+		nss = wifi->params.mgd_mode_mcast_fixed_nss;
+
+
+	seq_printf(m, "mgd_mode_mcast_fixed_data_rate = %d (%s)\n",
+		   mcs, get_string_from_rate(mcs, flags));
+
+	seq_puts(m, "Bits:80MHz-VHT-11N-SGI-40MHz-GF\n");
+	seq_printf(m, "mgd_mode_mcast_fixed_rate_flags = %d\n",
+		   wifi->params.mgd_mode_mcast_fixed_rate_flags);
+	seq_printf(m, "mgd_mode_mcast_fixed_bcc_or_ldpc = %d\n",
+		   wifi->params.mgd_mode_mcast_fixed_bcc_or_ldpc);
+	seq_printf(m, "mgd_mode_mcast_fixed_stbc_enabled = %d\n",
+		   wifi->params.mgd_mode_mcast_fixed_stbc_enabled);
+	seq_printf(m, "mgd_mode_mcast_fixed_preamble = %d\n",
+		   wifi->params.mgd_mode_mcast_fixed_preamble);
+	seq_printf(m, "mgd_mode_mcast_fixed_nss = %d\n", nss);
+	seq_puts(m, "***\n");
+
 	seq_printf(m, "vht_beamformer_enable = %d\n",
 		   wifi->params.vht_beamform_enable);
 	seq_printf(m, "vht_beamformer_period = %dms\n",
@@ -3152,13 +3255,13 @@ static int proc_read_config(struct seq_file *m, void *v)
 	if (uccp_debug & UCCP_DEBUG_TSMC)
 		seq_puts(m, "***uccp_debug: UCCP_DEBUG_TSMC Enabled\n");
 
-	seq_puts(m, "HELP: Add the values beside Module and\n");
+	seq_puts(m, "HELP: Add the values beside each module and\n");
 	seq_puts(m, " echo uccp_debug=<SUM> to enable logging\n");
 	seq_puts(m, " for those modules.\n");
-	seq_puts(m, "MODULE (Value): TSMC (4096), DUMP_HAL (1024), DUMP_RX (512),\n");
-	seq_puts(m, " CRYPTO(256), HAL(128), RX(64),\n");
-	seq_puts(m, " 80211IF(32), UMAC_IF(16), CORE(8),\n");
-	seq_puts(m, " TX(4), ROC(2), SCAN(1),\n");
+	seq_puts(m, " MODULE (Value): TSMC (4096), DUMP_HAL (2048), DUMP_RX (1024),\n");
+	seq_puts(m, " CRYPTO(512), HAL(256), RX(128),\n");
+	seq_puts(m, " 80211IF(64), UMAC_IF(32), CORE(16),\n");
+	seq_puts(m, " TX(8), ROC(4), SCAN(2),\n");
 
 	seq_puts(m, "To see the updated stats\n");
 	seq_puts(m, "please run: echo get_stats=1 > /proc/uccp420/params\n");
@@ -3360,6 +3463,11 @@ static int proc_read_mac_stats(struct seq_file *m, void *v)
 	int total_rssi_value = 0;
 	struct mac80211_dev *dev = NULL;
 
+	if (!wifi->hw)
+		return -ENODEV;
+
+	dev = (struct mac80211_dev *)(wifi->hw->priv);
+
 	if (ftm) {
 		for (index = 0; index < MAX_AUX_ADC_SAMPLES; index++) {
 			if (!wifi->params.pdout_voltage[index])
@@ -3471,7 +3579,6 @@ static int proc_read_mac_stats(struct seq_file *m, void *v)
 	seq_printf(m, "tx_done_recv_count = %d\n",
 		   wifi->stats.tx_done_recv_count);
 
-	dev = (struct mac80211_dev *)(wifi->hw->priv);
 	seq_printf(m, "tx_buff_pool_map = %ld\n",
 		   dev->tx.buf_pool_bmp[0]);
 	{
@@ -3480,6 +3587,7 @@ static int proc_read_mac_stats(struct seq_file *m, void *v)
 
 		seq_puts(m, "Pending Qs status\n");
 		for (i = 0; i < MAX_PEERS; i++) {
+
 			if (!dev->peers[i])
 				continue;
 
@@ -3487,7 +3595,8 @@ static int proc_read_mac_stats(struct seq_file *m, void *v)
 				spin_lock_bh(&dev->tx.lock);
 				pend_pkt_q = &dev->tx.pending_pkt[0][i][j];
 				if (skb_queue_len(pend_pkt_q))
-					seq_printf(m, "ac:%d peer:%d = %d\n",
+					seq_printf(m,
+						   "ac:%d peer:%d = %d\n",
 						   j,
 						   i,
 						   skb_queue_len(pend_pkt_q));
@@ -3588,10 +3697,13 @@ static ssize_t proc_write_config(struct file *file,
 	char buf[(RF_PARAMS_SIZE * 2) + 50];
 	unsigned long val;
 	long sval;
-	unsigned int rate = wifi->params.prod_mode_rate_flag;
-	unsigned int b40 = wifi->params.prod_mode_chnl_bw_40_mhz;
-	unsigned int b80 = wifi->params.prod_mode_chnl_bw_80_mhz;
-	struct mac80211_dev *dev = wifi->hw->priv;
+	struct mac80211_dev *dev;
+	int ret = 0;
+
+	if (!wifi->hw)
+		return -ENODEV;
+
+	dev = (struct mac80211_dev *)(wifi->hw->priv);
 
 	if (count >= sizeof(buf))
 		count = sizeof(buf) - 1;
@@ -3691,7 +3803,7 @@ static ssize_t proc_write_config(struct file *file,
 			pr_err("Interface is not initialized\n");
 			goto error;
 		}
-		uccp420wlan_prog_mib_stats();
+		CALL_UMAC(uccp420wlan_prog_mib_stats);
 	} else if (param_get_val(buf, "max_data_size=", &val)) {
 		if (wifi->params.max_data_size != val) {
 			if ((wifi->params.max_data_size >= 2 * 1024) &&
@@ -3776,65 +3888,40 @@ static ssize_t proc_write_config(struct file *file,
 			pr_err("Invalid parameter value, should be less than or equal to uccp_num_spatial_streams\n");
 	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_mcs_indx=", &sval)) {
 		if (wifi->params.mgd_mode_tx_fixed_rate == -1) {
-
-			int mcs_indx = wifi->params.mgd_mode_tx_fixed_mcs_indx;
-
-			if (vht_support && (wifi->params.prod_mode_rate_flag &
-					    ENABLE_VHT_FORMAT)) {
-				if ((sval >= -1) && (sval <= 9)) {
-					/* Get_rate will do the MCS holes
-					 * validation
-					 */
-					mcs_indx = sval;
-				} else
-					pr_err("Invalid parameter value.\n");
-			} else {
-				if (wifi->params.num_spatial_streams == 2) {
-					if ((sval >= -1) && (sval <= 15))
-						mcs_indx = sval;
-					else
-						pr_err("Invalid MIMO HT MCS: %ld\n",
-						       sval);
-				}
-				if (wifi->params.num_spatial_streams == 1) {
-					if ((sval >= -1) && (sval <= 7))
-						mcs_indx = sval;
-					else
-						pr_err("Invalid SISO HT MCS: %ld\n",
-						       sval);
-				}
-			}
-
-			wifi->params.mgd_mode_tx_fixed_mcs_indx = mcs_indx;
+			if (check_valid_data_rate(dev, sval | 0x80, UCAST))
+				wifi->params.mgd_mode_tx_fixed_mcs_indx = sval;
 		} else
 			pr_err("Fixed rate other than MCS index is currently set\n");
 	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_rate=", &sval)) {
 		if (wifi->params.mgd_mode_tx_fixed_mcs_indx == -1) {
-			int tx_fixed_rate = wifi->params.mgd_mode_tx_fixed_rate;
-
-			if (wifi->params.dot11g_support == 1 &&
-			    ((sval == 1) ||
-			     (sval == 2) ||
-			     (sval == 55) ||
-			     (sval == 11))) {
-				tx_fixed_rate = sval;
-			} else if ((sval == 6) ||
-				   (sval == 9) ||
-				   (sval == 12) ||
-				   (sval == 18) ||
-				   (sval == 24) ||
-				   (sval == 36) ||
-				   (sval == 48) ||
-				   (sval == 54) ||
-				   (sval == -1)) {
-				tx_fixed_rate = sval;
-			} else {
-				pr_err("Invalid parameter value.\n");
-				return count;
-			}
-			wifi->params.mgd_mode_tx_fixed_rate = tx_fixed_rate;
+			if (check_valid_data_rate(dev, sval, UCAST))
+				wifi->params.mgd_mode_tx_fixed_rate = sval;
 		} else
 			pr_err("MCS data rate(index) is currently set\n");
+	/* Multicast Rate configuration options.
+	 */
+	} else if (param_get_sval(buf, "mgd_mode_mcast_fixed_data_rate=",
+		   &sval)) {
+		if (check_valid_data_rate(dev, sval, MCAST))
+			wifi->params.mgd_mode_mcast_fixed_data_rate = sval;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_rate_flags=",
+		   &val)) {
+		if (check_valid_rate_flags(dev, val))
+			wifi->params.mgd_mode_mcast_fixed_rate_flags = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_bcc_or_ldpc=",
+		   &val)) {
+		wifi->params.mgd_mode_mcast_fixed_bcc_or_ldpc = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_stbc_enabled=",
+		   &val)) {
+		wifi->params.mgd_mode_mcast_fixed_stbc_enabled = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_preamble=",
+		   &val)) {
+		wifi->params.mgd_mode_mcast_fixed_preamble = val;
+	} else if (param_get_val(buf, "mgd_mode_mcast_fixed_nss=", &val)) {
+		wifi->params.mgd_mode_mcast_fixed_nss = val;
+
+	/* Production mode rate configuration
+	 */
 	} else if (param_get_sval(buf, "tx_fixed_mcs_indx=", &sval)) {
 		if (wifi->params.production_test != 1) {
 			pr_err("Only can be set in production mode.\n");
@@ -3850,32 +3937,10 @@ static ssize_t proc_write_config(struct file *file,
 			pr_err("Fixed rate other than MCS index is currently set\n");
 			goto error;
 		}
-		if (vht_support && (rate & ENABLE_VHT_FORMAT)) {
-			if ((sval >= -1) && (sval <= 9)) {
-				if ((b40 == 0) && (b80 == 0) && (sval == 9)) {
-					pr_err("Invalid VHT MCS: 20MHZ-MCS9.\n");
-					/*Reset to Default*/
-					wifi->params.tx_fixed_mcs_indx = 7;
-				} else
-					wifi->params.tx_fixed_mcs_indx = sval;
-			} else
-				pr_err("Invalid parameter value.\n");
-		} else if (vht_support && (rate & ENABLE_11N_FORMAT)) {
-			if (wifi->params.num_spatial_streams == 2) {
-				if ((sval >= -1) && (sval <= 15))
-					wifi->params.tx_fixed_mcs_indx = sval;
-				else
-					pr_err("Invalid MIMO HT MCS: %ld\n",
-						sval);
-			} else if (wifi->params.num_spatial_streams == 1) {
-				if ((sval >= -1) && (sval <= 7))
-					wifi->params.tx_fixed_mcs_indx = sval;
-				else
-					pr_err("Invalid SISO HT MCS: %ld\n",
-						sval);
-			}
-		} else
-			pr_err("MCS Setting is invalid for Legacy, please set prod_mode_rate_flag first.\n");
+
+		if (check_valid_data_rate(dev, sval | 0x80, UCAST))
+			wifi->params.tx_fixed_mcs_indx = sval;
+
 
 	} else if (param_get_sval(buf, "tx_fixed_rate=", &sval)) {
 		if (wifi->params.production_test != 1) {
@@ -3892,27 +3957,9 @@ static ssize_t proc_write_config(struct file *file,
 			goto error;
 		}
 
-		if ((wifi->params.dot11g_support == 1) &&
-			    ((sval == 1) ||
-			     (sval == 2) ||
-			     (sval == 55) ||
-			     (sval == 11))) {
-				wifi->params.tx_fixed_rate = sval;
-		} else if ((sval == 6) ||
-			   (sval == 9) ||
-			   (sval == 12) ||
-			   (sval == 18) ||
-			   (sval == 24) ||
-			   (sval == 36) ||
-			   (sval == 48) ||
-			   (sval == 54) ||
-			   (sval == -1)) {
-				wifi->params.tx_fixed_rate = sval;
-		} else {
-			pr_err("Invalid parameter value: tx_fixed_rate=%ld\n",
-				sval);
-			goto error;
-		}
+		if (check_valid_data_rate(dev, sval, UCAST))
+			wifi->params.tx_fixed_rate = sval;
+
 	} else if (param_get_val(buf, "chnl_bw=", &val)) {
 		if (((val == 0) ||
 		    (vht_support && (val == 2)) ||
@@ -4089,33 +4136,8 @@ static ssize_t proc_write_config(struct file *file,
 
 		} while (0);
 	} else if (param_get_val(buf, "prod_mode_rate_flag=", &val)) {
-		do {
-			/*Only first 6 flags are defined currently*/
-			if (val > 63)
-				pr_err("Invalid parameter value");
-
-			if ((val & ENABLE_VHT_FORMAT) &&
-			    (val & ENABLE_11N_FORMAT)) {
-				pr_err("Cannot set HT and VHT both.");
-				break;
-			}
-
-			if ((val & ENABLE_CHNL_WIDTH_40MHZ) &&
-			    (val & ENABLE_CHNL_WIDTH_80MHZ)) {
-				pr_err("Cannot set 40 and 80 both.");
-				break;
-			}
-
-			if ((wifi->params.uccp_num_spatial_streams == 1)  &&
-			    (val & ENABLE_SGI) &&
-			    (val & ENABLE_GREEN_FIELD)) {
-				pr_err("Cannot set GreenField when SGI is enabled for SISO");
-				break;
-			}
-
+		if (check_valid_rate_flags(dev, val))
 			wifi->params.prod_mode_rate_flag = val;
-		} while (0);
-
 	} else if (param_get_val(buf, "rate_protection_type=", &val)) {
 		/* 0 is None, 1 is RTS/CTS, 2 is for CTS2SELF */
 		if ((val == 0) || (val == 1) /*|| (val == 2)*/)
@@ -4179,7 +4201,9 @@ static ssize_t proc_write_config(struct file *file,
 				goto error;
 			}
 
-			uccp420wlan_prog_vht_bform(val, vht_beamform_period);
+			CALL_UMAC(uccp420wlan_prog_vht_bform,
+				  val,
+				  vht_beamform_period);
 		} while (0);
 
 	} else if (param_get_val(buf, "vht_beamformer_period=", &val)) {
@@ -4221,7 +4245,9 @@ static ssize_t proc_write_config(struct file *file,
 				goto error;
 			}
 
-			uccp420wlan_prog_vht_bform(vht_beamform_enable, val);
+			CALL_UMAC(uccp420wlan_prog_vht_bform,
+				  vht_beamform_enable,
+				  val);
 		} while (0);
 
 	} else if (param_get_val(buf, "bg_scan_enable=", &val)) {
@@ -4272,7 +4298,9 @@ static ssize_t proc_write_config(struct file *file,
 		if ((val == 1) || (val == 0)) {
 			wifi->params.nw_selection = val;
 			pr_err("in nw_selection\n");
-			uccp420wlan_prog_nw_selection(1, vif_macs[0]);
+			CALL_UMAC(uccp420wlan_prog_nw_selection,
+				  1,
+				  vif_macs[0]);
 		} else
 			pr_err("Invalid nw selection value should be 1 or 0\n");
 	} else if (param_get_val(buf, "scan_type=", &val)) {
@@ -4292,7 +4320,7 @@ static ssize_t proc_write_config(struct file *file,
 		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
 		if ((val == AUX_ADC_CHAIN1) || (val == AUX_ADC_CHAIN2)) {
 			wifi->params.aux_adc_chain_id = val;
-			uccp420wlan_prog_aux_adc_chain(val);
+			CALL_UMAC(uccp420wlan_prog_aux_adc_chain, val);
 		} else
 			pr_err("Invalid chain id %d, should be %d or %d\n",
 			       (unsigned int) val,
@@ -4311,96 +4339,96 @@ static ssize_t proc_write_config(struct file *file,
 
 		if (val == 0 || val == 1) {
 			wifi->params.cont_tx = val;
-			uccp420wlan_prog_cont_tx(val);
+			CALL_UMAC(uccp420wlan_prog_cont_tx, val);
 		} else
 			pr_err("Invalid tx_continuous parameter\n");
 	} else if (param_get_val(buf, "start_prod_mode=", &val)) {
-			unsigned int pri_chnl_num = 0;
-			unsigned int freq_band = IEEE80211_BAND_5GHZ;
-			int center_freq = 0;
+		unsigned int pri_chnl_num = 0;
+		unsigned int freq_band = IEEE80211_BAND_5GHZ;
+		int center_freq = 0;
 
-			if (wifi->params.production_test != 1) {
-				pr_err("start_prod_mode: Can be set in only in production mode.\n");
-				goto error;
-			}
+		if (wifi->params.production_test != 1) {
+			pr_err("start_prod_mode: Can be set in only in production mode.\n");
+			goto error;
+		}
 
-			if (wifi->params.init_prod) {
-				pr_err("Production Test is already initialized.\n");
-				goto error;
-			}
+		if (wifi->params.init_prod) {
+			pr_err("Production Test is already initialized.\n");
+			goto error;
+		}
 
-			pri_chnl_num = val;
-			wifi->params.start_prod_mode = val;
-			tasklet_init(&dev->proc_tx_tasklet, packet_generation,
-				     (unsigned long)dev);
-			if (pri_chnl_num < 15)
-				freq_band = IEEE80211_BAND_2GHZ;
-			else
-				freq_band = IEEE80211_BAND_5GHZ;
+		pri_chnl_num = val;
+		wifi->params.start_prod_mode = val;
+		tasklet_init(&dev->proc_tx_tasklet, packet_generation,
+			     (unsigned long)dev);
+		if (pri_chnl_num < 15)
+			freq_band = IEEE80211_BAND_2GHZ;
+		else
+			freq_band = IEEE80211_BAND_5GHZ;
 
-			center_freq =
-			ieee80211_channel_to_frequency(pri_chnl_num,
-						       freq_band);
+		center_freq =
+		ieee80211_channel_to_frequency(pri_chnl_num,
+					       freq_band);
 
-			if ((wifi->params.fw_loading == 1) &&
-			     load_fw(dev->hw)) {
-				pr_err("%s: Firmware loading failed\n",
-				       dev->name);
-				goto error;
-			}
+		if ((wifi->params.fw_loading == 1) &&
+		     load_fw(dev->hw)) {
+			pr_err("%s: Firmware loading failed\n",
+			       dev->name);
+			goto error;
+		}
 
-			if (!uccp420wlan_core_init(dev, ftm)) {
-				uccp420wlan_prog_vif_ctrl(0,
-						dev->if_mac_addresses[0].addr,
-						IF_MODE_STA_IBSS,
-						IF_ADD);
-
-				proc_bss_info_changed(
-						dev->if_mac_addresses[0].addr,
-						val);
-
-				uccp420wlan_prog_channel(pri_chnl_num,
-							center_freq,
-							 0,
-							 0,
-					/*It will be overwritten anyway*/
+		if (!uccp420wlan_core_init(dev, ftm)) {
+			uccp420wlan_prog_vif_ctrl(0,
+					dev->if_mac_addresses[0].addr,
+					IF_MODE_STA_IBSS,
+					IF_ADD);
+
+			proc_bss_info_changed(
+					dev->if_mac_addresses[0].addr,
+					val);
+
+			uccp420wlan_prog_channel(pri_chnl_num,
+						center_freq,
+						 0,
+						 0,
+				/*It will be overwritten anyway*/
 #ifdef MULTI_CHAN_SUPPORT
-							 0,
+						 0,
 #endif
-							 freq_band);
-				skb_queue_head_init(&dev->tx.proc_tx_list[0]);
-				wifi->params.init_prod = 1;
-				dev->state = STARTED;
-				uccp_reinit = 0;
-			 } else {
-				pr_err("RPU Initialization Failed\n");
-				wifi->params.init_prod = 0;
-			}
+						 freq_band);
+			skb_queue_head_init(&dev->tx.proc_tx_list[0]);
+			wifi->params.init_prod = 1;
+			dev->state = STARTED;
+			uccp_reinit = 0;
+		 } else {
+			pr_err("RPU Initialization Failed\n");
+			wifi->params.init_prod = 0;
+		}
 
 	} else if (param_get_sval(buf, "stop_prod_mode=", &sval)) {
 
-			if (!wifi->params.init_prod) {
-				DEBUG_LOG("Prod mode is not initialized\n");
-				goto error;
-			}
+		if (!wifi->params.init_prod) {
+			DEBUG_LOG("Prod mode is not initialized\n");
+			goto error;
+		}
 
-			tasklet_kill(&dev->proc_tx_tasklet);
+		tasklet_kill(&dev->proc_tx_tasklet);
 #if 0
-			/* Todo: Enabling this causes RPU Lockup,
-			 * need to debug
-			 */
-			uccp420wlan_prog_vif_ctrl(0,
-						  dev->if_mac_addresses[0].addr,
-						  IF_MODE_STA_IBSS,
-						  IF_REM);
+		/* Todo: Enabling this causes RPU Lockup,
+		 * need to debug
+		 */
+		uccp420wlan_prog_vif_ctrl(0,
+					  dev->if_mac_addresses[0].addr,
+					  IF_MODE_STA_IBSS,
+					  IF_REM);
 #endif
-			if (!uccp_reinit)
-				stop(wifi->hw);
+		if (!uccp_reinit)
+			stop(wifi->hw);
 
-			wifi->params.start_prod_mode = 0;
-			wifi->params.pkt_gen_val = 1;
-			wifi->params.init_prod = 0;
-			wifi->params.init_pkt_gen = 0;
+		wifi->params.start_prod_mode = 0;
+		wifi->params.pkt_gen_val = 1;
+		wifi->params.init_prod = 0;
+		wifi->params.init_pkt_gen = 0;
 	} else if (param_get_sval(buf, "start_packet_gen=", &sval)) {
 
 
@@ -4452,7 +4480,7 @@ static ssize_t proc_write_config(struct file *file,
 		memset(wifi->params.pdout_voltage, 0,
 		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
 		wifi->params.set_tx_power = sval;
-		uccp420wlan_prog_txpower(sval);
+		CALL_UMAC(uccp420wlan_prog_txpower, sval);
 #ifdef PERF_PROFILING
 	} else if (param_get_val(buf, "driver_tput=", &val)) {
 		if ((val == 1) || (val == 0))
@@ -4461,7 +4489,7 @@ static ssize_t proc_write_config(struct file *file,
 			pr_err("Invalid driver_tput value should be 1 or 0\n");
 #endif
 	} else if (param_get_val(buf, "fw_loading=", &val)) {
-			wifi->params.fw_loading = val;
+		wifi->params.fw_loading = val;
 	} else if (param_get_val(buf, "bt_state=", &val)) {
 		if (dev->state != STARTED) {
 			pr_err("Interface is not initialized\n");
@@ -4471,7 +4499,7 @@ static ssize_t proc_write_config(struct file *file,
 		if (val == 0 || val == 1) {
 			if (val != wifi->params.bt_state) {
 				wifi->params.bt_state = val;
-				uccp420wlan_prog_btinfo(val);
+				CALL_UMAC(uccp420wlan_prog_btinfo, val);
 			}
 		} else
 			pr_err("Invalid parameter value: Allowed values: 0 or 1\n");
@@ -4480,7 +4508,7 @@ static ssize_t proc_write_config(struct file *file,
 			pr_err("Interface is not initialized\n");
 			goto error;
 		}
-		uccp420wlan_prog_clear_stats();
+		CALL_UMAC(uccp420wlan_prog_clear_stats);
 	} else if (param_get_val(buf, "disable_beacon_ibss=", &val)) {
 		if ((val == 1) || (val == 0))
 			wifi->params.disable_beacon_ibss = val;
@@ -4499,6 +4527,8 @@ static ssize_t proc_write_config(struct file *file,
 		pr_err("Invalid parameter name: %s\n", buf);
 error:
 	return count;
+prog_umac_fail:
+	return ret;
 }
 
 
@@ -4623,8 +4653,16 @@ static int proc_init(struct proc_dir_entry ***main_dir_entry)
 
 	wifi->params.enable_early_agg_checks = 1;
 	wifi->params.bt_state = 1;
+
+	/* Defaults optimized for all IMG clients
+	 */
 	wifi->params.mgd_mode_tx_fixed_mcs_indx = -1;
+	wifi->params.mgd_mode_mcast_fixed_data_rate = -1;
 	wifi->params.mgd_mode_tx_fixed_rate = -1;
+	wifi->params.mgd_mode_mcast_fixed_nss = 1;
+	wifi->params.mgd_mode_mcast_fixed_bcc_or_ldpc = 1;
+	wifi->params.mgd_mode_mcast_fixed_stbc_enabled = 1;
+
 	if (vht_support)
 		wifi->params.chnl_bw = WLAN_80MHZ_OPERATION;
 	else
diff --git a/drivers/net/wireless/uccp420wlan/src/core.c b/drivers/net/wireless/uccp420wlan/src/core.c
index 22e0e22..b5bfb35 100644
--- a/drivers/net/wireless/uccp420wlan/src/core.c
+++ b/drivers/net/wireless/uccp420wlan/src/core.c
@@ -28,28 +28,30 @@
 
 #define UMAC_PRINT(fmt, args...) pr_debug(fmt, ##args)
 
-#define UCCP_DEBUG_CORE(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_CORE)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_CORE(fmt, ...)            \
+do {                                          \
+	if (uccp_debug & UCCP_DEBUG_CORE)      \
+		pr_debug(fmt, ##__VA_ARGS__);   \
 } while (0)
 
-#define UCCP_DEBUG_RX(fmt, ...)                           \
-do {                                                                    \
-		if ((uccp_debug & UCCP_DEBUG_RX) && net_ratelimit())     \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_RX(fmt, ...)                            \
+do {                                                        \
+	if ((uccp_debug & UCCP_DEBUG_RX) && net_ratelimit()) \
+		pr_debug(fmt, ##__VA_ARGS__);                 \
 } while (0)
 
 
 #define UCCP_DEBUG_DUMP_RX(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_DUMP_RX)                       \
-			print_hex_dump(KERN_DEBUG, fmt, ##__VA_ARGS__);  \
+do {                                                            \
+	if (uccp_debug & UCCP_DEBUG_DUMP_RX)                     \
+		print_hex_dump(KERN_DEBUG, fmt, ##__VA_ARGS__);   \
 } while (0)
 
 
 #define DUMP_RX (uccp_debug & UCCP_DEBUG_DUMP_RX)
 
+
+
 spinlock_t tsf_lock;
 
 unsigned char bss_addr[6] = {72, 14, 29, 35, 31, 52};
@@ -120,7 +122,7 @@ check_scan_abort_complete:
 	if (!dev->scan_abort_done && (count < SCAN_ABORT_TIMEOUT_TICKS)) {
 		current->state = TASK_INTERRUPTIBLE;
 
-		if (0 == schedule_timeout(1))
+		if (schedule_timeout(1) == 0)
 			count++;
 
 		goto check_scan_abort_complete;
@@ -147,7 +149,7 @@ int wait_for_cancel_hw_roc(struct mac80211_dev *dev)
 check_cancel_hw_roc_complete:
 	if (!dev->cancel_hw_roc_done && (count < CANCEL_HW_ROC_TIMEOUT_TICKS)) {
 		current->state = TASK_INTERRUPTIBLE;
-		if (0 == schedule_timeout(1))
+		if (schedule_timeout(1) == 0)
 			count++;
 		goto check_cancel_hw_roc_complete;
 	}
@@ -177,7 +179,7 @@ check_ch_prog_complete:
 	if (!dev->chan_prog_done && (count < CH_PROG_TIMEOUT_TICKS)) {
 		current->state = TASK_INTERRUPTIBLE;
 
-		if (0 == schedule_timeout(1))
+		if (schedule_timeout(1) == 0)
 			count++;
 
 		goto check_ch_prog_complete;
@@ -196,6 +198,32 @@ check_ch_prog_complete:
 
 }
 
+int wait_for_tx_deinit_complete(struct mac80211_dev *dev)
+{
+	int count = 0;
+
+check_tx_deinit_complete:
+	if (!dev->tx_deinit_complete &&
+	    (count < TX_DEINIT_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+		if (schedule_timeout(1) == 0)
+			count++;
+		goto check_tx_deinit_complete;
+	}
+
+	if (!dev->tx_deinit_complete) {
+		pr_err("%s-UMAC: Warning: Tx discard failed after %ld timer ticks\n",
+		       dev->name,
+		       TX_DEINIT_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	UCCP_DEBUG_CORE("Discarded Tx successfully in %d timer ticks\n",
+			count);
+
+	return 0;
+}
+
 int wait_for_tx_queue_flush_complete(struct mac80211_dev *dev,
 				     unsigned int queue)
 {
@@ -205,7 +233,7 @@ check_tx_queue_flush_complete:
 	if (dev->tx.outstanding_tokens[queue] &&
 	    (count < QUEUE_FLUSH_TIMEOUT_TICKS)) {
 		current->state = TASK_INTERRUPTIBLE;
-		if (0 == schedule_timeout(1))
+		if (schedule_timeout(1) == 0)
 			count++;
 		goto check_tx_queue_flush_complete;
 	}
@@ -239,7 +267,7 @@ check_reset_complete:
 	if (!dev->reset_complete && (count < RESET_TIMEOUT_TICKS)) {
 		current->state = TASK_INTERRUPTIBLE;
 
-		if (0 == schedule_timeout(1))
+		if (schedule_timeout(1) == 0)
 			count++;
 
 		goto check_reset_complete;
@@ -291,7 +319,7 @@ static void driver_tput_timer_expiry(unsigned long data)
 
 void proc_bss_info_changed(unsigned char *mac_addr, int value)
 {
-		int temp = 0, i = 0, j = 0;
+		int temp = 0, i = 0, j = 0, ret = 0;
 
 		get_random_bytes(&j, sizeof(j));
 		for (i = 5; i > 0; i--) {
@@ -300,8 +328,12 @@ void proc_bss_info_changed(unsigned char *mac_addr, int value)
 			bss_addr[i] = bss_addr[j];
 			bss_addr[j] = temp;
 			}
-		uccp420wlan_prog_vif_bssid(0, mac_addr, bss_addr);
-
+		CALL_UMAC(uccp420wlan_prog_vif_bssid,
+			  0,
+			  mac_addr,
+			  bss_addr);
+prog_umac_fail:
+	return;
 }
 
 void packet_generation(unsigned long data)
@@ -425,6 +457,7 @@ reschedule_timer:
 
 int uccp420wlan_core_init(struct mac80211_dev *dev, unsigned int ftm)
 {
+	int ret = 0;
 
 	UCCP_DEBUG_CORE("%s-UMAC: Init called\n", dev->name);
 	spin_lock_init(&tsf_lock);
@@ -435,47 +468,64 @@ int uccp420wlan_core_init(struct mac80211_dev *dev, unsigned int ftm)
 
 	UMAC_PRINT("%s-UMAC: Reset (ENABLE)\n", dev->name);
 
-	if (hal_ops.start())
+	if (hal_ops.start()) {
+		ret = -1;
 		goto lmac_deinit;
+	}
 
 	if (hal_ops.init_bufs(NUM_TX_DESCS,
 			      NUM_RX_BUFS_2K,
 			      NUM_RX_BUFS_12K,
-			      dev->params->max_data_size) < 0)
+			      dev->params->max_data_size) < 0) {
+		ret = -1;
 		goto hal_stop;
+	}
 
 	if (ftm)
-		uccp420wlan_prog_reset(LMAC_ENABLE, LMAC_MODE_FTM);
+		CALL_UMAC(uccp420wlan_prog_reset,
+			  LMAC_ENABLE,
+			  LMAC_MODE_FTM);
 	else
-		uccp420wlan_prog_reset(LMAC_ENABLE, LMAC_MODE_NORMAL);
+		CALL_UMAC(uccp420wlan_prog_reset,
+			  LMAC_ENABLE,
+			  LMAC_MODE_NORMAL);
 
-	if (wait_for_reset_complete(dev) < 0)
+	if (wait_for_reset_complete(dev) < 0) {
+		ret = -1;
 		goto hal_deinit_bufs;
+	}
+
+
+	CALL_UMAC(uccp420wlan_prog_btinfo, dev->params->bt_state);
 
+	CALL_UMAC(uccp420wlan_prog_global_cfg,
+		  512, /* Rx MSDU life time in msecs */
+		  512, /* Tx MSDU life time in msecs */
+		  dev->params->ed_sensitivity,
+		  dev->params->auto_sensitivity,
+		  dev->params->rf_params);
 
-	uccp420wlan_prog_btinfo(dev->params->bt_state);
-	uccp420wlan_prog_global_cfg(512, /* Rx MSDU life time in msecs */
-				    512, /* Tx MSDU life time in msecs */
-				    dev->params->ed_sensitivity,
-				    dev->params->auto_sensitivity,
-				    dev->params->rf_params);
+	CALL_UMAC(uccp420wlan_prog_txpower, dev->txpower);
 
-	uccp420wlan_prog_txpower(dev->txpower);
 	uccp420wlan_tx_init(dev);
 
+
 	return 0;
 hal_deinit_bufs:
 	hal_ops.deinit_bufs();
+prog_umac_fail:
 hal_stop:
 	hal_ops.stop();
 lmac_deinit:
 	uccp420wlan_lmac_if_deinit();
-	return -1;
+	return ret;
 }
 
 
 void uccp420wlan_core_deinit(struct mac80211_dev *dev, unsigned int ftm)
 {
+	int ret = 0;
+
 	UCCP_DEBUG_CORE("%s-UMAC: De-init called\n", dev->name);
 
 	/* De initialize tx  and disable LMAC*/
@@ -486,13 +536,17 @@ void uccp420wlan_core_deinit(struct mac80211_dev *dev, unsigned int ftm)
 	UMAC_PRINT("%s-UMAC: Reset (DISABLE)\n", dev->name);
 
 	if (ftm)
-		uccp420wlan_prog_reset(LMAC_DISABLE, LMAC_MODE_FTM);
+		CALL_UMAC(uccp420wlan_prog_reset,
+			  LMAC_DISABLE,
+			  LMAC_MODE_FTM);
 	else
-		uccp420wlan_prog_reset(LMAC_DISABLE, LMAC_MODE_NORMAL);
-
+		CALL_UMAC(uccp420wlan_prog_reset,
+			  LMAC_DISABLE,
+			  LMAC_MODE_NORMAL);
 
 	wait_for_reset_complete(dev);
 
+prog_umac_fail:
 	uccp420_lmac_if_free_outstnding();
 
 	hal_ops.stop();
@@ -506,6 +560,7 @@ void uccp420wlan_vif_add(struct umac_vif *uvif)
 {
 	unsigned int type;
 	struct ieee80211_conf *conf = &uvif->dev->hw->conf;
+	int ret = 0;
 
 	UCCP_DEBUG_CORE("%s-UMAC: Add VIF %d Type = %d\n",
 		   uvif->dev->name,
@@ -547,17 +602,20 @@ void uccp420wlan_vif_add(struct umac_vif *uvif)
 	uvif->driver_tput_timer.data = (unsigned long)uvif;
 	uvif->driver_tput_timer.function = driver_tput_timer_expiry;
 #endif
-	uccp420wlan_prog_vif_ctrl(uvif->vif_index,
-				  uvif->vif->addr,
-				  type,
-				  IF_ADD);
+	CALL_UMAC(uccp420wlan_prog_vif_ctrl,
+		  uvif->vif_index,
+		  uvif->vif->addr,
+		  type,
+		  IF_ADD);
 
 	/* Reprogram retry counts */
-	uccp420wlan_prog_short_retry(uvif->vif_index, uvif->vif->addr,
-					 conf->short_frame_max_tx_count);
+	CALL_UMAC(uccp420wlan_prog_short_retry,
+		  uvif->vif_index, uvif->vif->addr,
+		  conf->short_frame_max_tx_count);
 
-	uccp420wlan_prog_long_retry(uvif->vif_index, uvif->vif->addr,
-					conf->long_frame_max_tx_count);
+	CALL_UMAC(uccp420wlan_prog_long_retry,
+		  uvif->vif_index, uvif->vif->addr,
+		  conf->long_frame_max_tx_count);
 
 	if (uvif->vif->type == NL80211_IFTYPE_AP) {
 		/* Program the EDCA params */
@@ -575,16 +633,19 @@ void uccp420wlan_vif_add(struct umac_vif *uvif)
 			cwmax = uvif->config.edca_params[queue].cwmax;
 			uapsd = uvif->config.edca_params[queue].uapsd;
 
-			uccp420wlan_prog_txq_params(uvif->vif_index,
-						    uvif->vif->addr,
-						    queue,
-						    aifs,
-						    txop,
-						    cwmin,
-						    cwmax,
-						    uapsd);
+			CALL_UMAC(uccp420wlan_prog_txq_params,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  queue,
+				  aifs,
+				  txop,
+				  cwmin,
+				  cwmax,
+				  uapsd);
 		}
 	}
+prog_umac_fail:
+	return;
 }
 
 
@@ -592,6 +653,7 @@ void uccp420wlan_vif_remove(struct umac_vif *uvif)
 {
 	struct sk_buff *skb;
 	unsigned int type;
+	int ret = 0;
 
 	UCCP_DEBUG_CORE("%s-UMAC: Remove VIF %d called\n",
 					uvif->dev->name,
@@ -625,11 +687,14 @@ void uccp420wlan_vif_remove(struct umac_vif *uvif)
 
 	spin_unlock_bh(&uvif->noa_que.lock);
 
-	uccp420wlan_prog_vif_ctrl(uvif->vif_index,
-				  uvif->vif->addr,
-				  type,
-				  IF_REM);
+	CALL_UMAC(uccp420wlan_prog_vif_ctrl,
+		  uvif->vif_index,
+		  uvif->vif->addr,
+		  type,
+		  IF_REM);
 
+prog_umac_fail:
+	return;
 }
 
 
@@ -638,6 +703,8 @@ void uccp420wlan_vif_set_edca_params(unsigned short queue,
 				     struct edca_params *params,
 				     unsigned int vif_active)
 {
+	int ret = 0;
+
 	switch (queue) {
 	case 0:
 		queue = 3; /* Voice */
@@ -688,15 +755,17 @@ void uccp420wlan_vif_set_edca_params(unsigned short queue,
 		return;
 
 	/* Program the txq parameters into the LMAC */
-	uccp420wlan_prog_txq_params(uvif->vif_index,
-				    uvif->vif->addr,
-				    queue,
-				    params->aifs,
-				    params->txop,
-				    params->cwmin,
-				    params->cwmax,
-				    params->uapsd);
-
+	CALL_UMAC(uccp420wlan_prog_txq_params,
+		  uvif->vif_index,
+		  uvif->vif->addr,
+		  queue,
+		  params->aifs,
+		  params->txop,
+		  params->cwmin,
+		  params->cwmax,
+		  params->uapsd);
+prog_umac_fail:
+	return;
 }
 
 
@@ -711,24 +780,29 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 	int chan = 0;
 	unsigned int bform_enable = 0;
 	unsigned int bform_per = 0;
+	int ret = 0;
 
 	UCCP_DEBUG_CORE("%s-CORE: BSS INFO changed %d, %d, %d\n",
 		uvif->dev->name, uvif->vif_index, uvif->vif->type, changed);
 
 
 	if (changed & BSS_CHANGED_BSSID)
-		uccp420wlan_prog_vif_bssid(uvif->vif_index, uvif->vif->addr,
-					   (unsigned char *)bss_conf->bssid);
+		CALL_UMAC(uccp420wlan_prog_vif_bssid,
+			   uvif->vif_index,
+			   uvif->vif->addr,
+			   (unsigned char *)bss_conf->bssid);
 
 	if (changed & BSS_CHANGED_BASIC_RATES) {
 		if (bss_conf->basic_rates)
-			uccp420wlan_prog_vif_basic_rates(uvif->vif_index,
-							 uvif->vif->addr,
-							 bss_conf->basic_rates);
+			CALL_UMAC(uccp420wlan_prog_vif_basic_rates,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  bss_conf->basic_rates);
 		else
-			uccp420wlan_prog_vif_basic_rates(uvif->vif_index,
-							 uvif->vif->addr,
-							 0x153);
+			CALL_UMAC(uccp420wlan_prog_vif_basic_rates,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  0x153);
 	}
 
 	if (changed & BSS_CHANGED_ERP_SLOT) {
@@ -739,9 +813,10 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 		unsigned int cwmax = 0;
 		unsigned int uapsd = 0;
 
-		uccp420wlan_prog_vif_short_slot(uvif->vif_index,
-						uvif->vif->addr,
-						bss_conf->use_short_slot);
+		CALL_UMAC(uccp420wlan_prog_vif_short_slot,
+			  uvif->vif_index,
+			  uvif->vif->addr,
+			  bss_conf->use_short_slot);
 
 		for (queue = 0; queue < WLAN_AC_MAX_CNT; queue++) {
 			aifs = uvif->config.edca_params[queue].aifs;
@@ -751,14 +826,15 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 			uapsd = uvif->config.edca_params[queue].uapsd;
 
 			if (uvif->config.edca_params[queue].cwmin != 0)
-				uccp420wlan_prog_txq_params(uvif->vif_index,
-							    uvif->vif->addr,
-							    queue,
-							    aifs,
-							    txop,
-							    cwmin,
-							    cwmax,
-							    uapsd);
+				CALL_UMAC(uccp420wlan_prog_txq_params,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  queue,
+					  aifs,
+					  txop,
+					  cwmin,
+					  cwmax,
+					  uapsd);
 		}
 	}
 
@@ -777,28 +853,33 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 					   bss_conf->assoc_capability |
 					   (bss_conf->qos << 9));
 
-				uccp420wlan_prog_vif_conn_state(uvif->vif_index,
-								uvif->vif->addr,
-								STA_CONN);
+				CALL_UMAC(uccp420wlan_prog_vif_conn_state,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  STA_CONN);
 
-				uccp420wlan_prog_vif_aid(uvif->vif_index,
-							 uvif->vif->addr,
-							 bss_conf->aid);
+				CALL_UMAC(uccp420wlan_prog_vif_aid,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  bss_conf->aid);
 
-				uccp420wlan_prog_vif_op_channel(uvif->vif_index,
-								uvif->vif->addr,
-								chan);
+				CALL_UMAC(uccp420wlan_prog_vif_op_channel,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  chan);
 
 				caps = (bss_conf->assoc_capability |
 					(bss_conf->qos << 9));
 
-				uccp420wlan_prog_vif_assoc_cap(uvif->vif_index,
-							       uvif->vif->addr,
-							       caps);
+				CALL_UMAC(uccp420wlan_prog_vif_assoc_cap,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  caps);
 
 				if (uvif->dev->params->vht_beamform_support)
-					uccp420wlan_prog_vht_bform(bform_enable,
-								   bform_per);
+					CALL_UMAC(uccp420wlan_prog_vht_bform,
+						  bform_enable,
+						  bform_per);
 
 				uvif->noa_active = 0;
 				uvif->dev->params->is_associated = 1;
@@ -810,28 +891,32 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 			} else {
 				uvif->dev->params->is_associated = 0;
 
-				uccp420wlan_prog_vif_conn_state(uvif->vif_index,
-								uvif->vif->addr,
-								STA_DISCONN);
+				CALL_UMAC(uccp420wlan_prog_vif_conn_state,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  STA_DISCONN);
 
-				uccp420wlan_prog_vht_bform(VHT_BEAMFORM_DISABLE,
-							   bform_per);
+				CALL_UMAC(uccp420wlan_prog_vht_bform,
+					  VHT_BEAMFORM_DISABLE,
+					  bform_per);
 				uvif->dev->params->
 					sync[uvif->vif_index].status = 0;
 			}
 		}
 
 		if (changed & BSS_CHANGED_BEACON_INT) {
-			uccp420wlan_prog_vif_beacon_int(uvif->vif_index,
-							uvif->vif->addr,
-							bss_conf->beacon_int);
+			CALL_UMAC(uccp420wlan_prog_vif_beacon_int,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				  bss_conf->beacon_int);
 
 		}
 
 		if (changed & BSS_CHANGED_BEACON_INFO) {
-			uccp420wlan_prog_vif_dtim_period(uvif->vif_index,
-							 uvif->vif->addr,
-							 bss_conf->dtim_period);
+			CALL_UMAC(uccp420wlan_prog_vif_dtim_period,
+				  uvif->vif_index,
+				  uvif->vif->addr,
+				   bss_conf->dtim_period);
 
 		}
 
@@ -858,9 +943,10 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 				mod_timer(&uvif->bcn_timer,
 					  jiffies + bcn_tim_val);
 
-				uccp420wlan_prog_vif_beacon_int(uvif->vif_index,
-								uvif->vif->addr,
-								bcn_int);
+				CALL_UMAC(uccp420wlan_prog_vif_beacon_int,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  bcn_int);
 			}
 		}
 
@@ -887,9 +973,10 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 				mod_timer(&uvif->bcn_timer,
 					  jiffies + bcn_tim_val);
 
-				uccp420wlan_prog_vif_beacon_int(uvif->vif_index,
-								uvif->vif->addr,
-								bcn_int);
+				CALL_UMAC(uccp420wlan_prog_vif_beacon_int,
+					  uvif->vif_index,
+					  uvif->vif->addr,
+					  bcn_int);
 			}
 		}
 
@@ -898,7 +985,8 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 		WARN_ON(1);
 		return;
 	}
-
+prog_umac_fail:
+	return;
 }
 
 
diff --git a/drivers/net/wireless/uccp420wlan/src/fwldr.c b/drivers/net/wireless/uccp420wlan/src/fwldr.c
index a790335..d16338c 100644
--- a/drivers/net/wireless/uccp420wlan/src/fwldr.c
+++ b/drivers/net/wireless/uccp420wlan/src/fwldr.c
@@ -23,13 +23,13 @@
  * USA.
  */
 
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
-#include <linux/dma-mapping.h>
-#include <linux/delay.h>
 #include <linux/slab.h>
 
-#include <fwldr.h>
+#include "fwldr.h"
 
 struct fwload_priv  *fpriv, fpv;
 
@@ -1181,7 +1181,7 @@ static int fwldr_wait_for_completion(void)
 
 		i++;
 
-	} while ((UCCP_THRD_EXEC_SIG != rw_v.val) && (i < 1000));
+	} while ((rw_v.val != UCCP_THRD_EXEC_SIG) && (i < 1000));
 
 	if (i == 1000)
 		result = 0;
diff --git a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
index 7bbb0b0..32f680e 100644
--- a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
+++ b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
@@ -22,33 +22,31 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
  * USA.
  */
+#include <asm/unaligned.h>
 
+#include <linux/clk.h>
+#include <linux/etherdevice.h>
+#include <linux/iio/consumer.h>
+#include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/interrupt.h>
-#include <linux/skbuff.h>
-#include <linux/slab.h>
 #include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_device.h>
 #include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/syscore_ops.h>
+#include <linux/time.h>
 
-#include <asm/unaligned.h>
 
-#include <linux/time.h>
-#include <linux/sort.h>
-#include <linux/etherdevice.h>
 #include "core.h"
+#include "fwldr.h"
 #include "hal.h"
 #include "hal_hostport.h"
-#include "fwldr.h"
 
-#include <linux/of.h>
-#include <linux/of_net.h>
-#include <linux/of_device.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-#include <linux/iio/consumer.h>
-#include <linux/proc_fs.h>
-#include <linux/syscore_ops.h>
 
 #define COMMAND_START_MAGIC 0xDEAD
 
@@ -71,7 +69,8 @@ unsigned int hal_event_recv;
 struct timer_list stats_timer;
 unsigned int alloc_skb_failures;
 unsigned int alloc_skb_dma_region;
-unsigned int alloc_skb_priv_region;
+unsigned int alloc_skb_priv_tx_region;
+unsigned int alloc_skb_priv_rx_region;
 unsigned int alloc_skb_priv_runtime;
 
 static unsigned int uccp_ddr_base;
@@ -225,7 +224,7 @@ int hal_get_dump_core(unsigned long  *dump_start, unsigned char region_type)
 {
 	unsigned int *core_dump;
 	unsigned long len = 0;
-	unsigned long region_start;
+	unsigned long region_start = 0;
 
 	if (region_type == UCCP_REGION_TYPE_COREA) {
 		len = UCCP_COREA_REGION_LEN;
@@ -338,7 +337,7 @@ static void tx_tasklet_fn(unsigned long data)
 
 		while (!hal_ready(priv) &&
 		     time_before(jiffies, start + msecs_to_jiffies(1000))) {
-			;
+			cpu_relax();
 		}
 
 		if (!hal_ready(priv)) {
@@ -1082,8 +1081,11 @@ static int proc_read_hal_stats(struct seq_file *m, void *v)
 	seq_printf(m, "Alloc SKB in 60 MB DMA Region  %d\n",
 		   alloc_skb_dma_region);
 
-	seq_printf(m, "Alloc SKB in Priv 4 MB Region: %d\n",
-		   alloc_skb_priv_region);
+	seq_printf(m, "Alloc SKB in Priv 4 MB TX Region: %d\n",
+		   alloc_skb_priv_tx_region);
+
+	seq_printf(m, "Alloc SKB in Priv 4 MB RX Region: %d\n",
+		   alloc_skb_priv_rx_region);
 
 	seq_printf(m, "Alloc SKB Run time: %d\n", alloc_skb_priv_runtime);
 
@@ -1141,10 +1143,10 @@ static void stats_timer_expiry(unsigned long data)
 		alloc_skb_dma_region = 0;
 	}
 
-	if (alloc_skb_priv_region) {
+	if (alloc_skb_priv_rx_region) {
 		pr_info("Alloc SKB in Priv 4 MB Region: %d\n",
-			alloc_skb_priv_region);
-		alloc_skb_priv_region = 0;
+			alloc_skb_priv_rx_region);
+		alloc_skb_priv_rx_region = 0;
 	}
 
 	if (alloc_skb_failures) {
@@ -1249,7 +1251,7 @@ static inline int conv_str_to_byte(unsigned char *byte,
 /* Unmap and release all resoruces*/
 static int cleanup_all_resources(void)
 {
-	/* Unmap UCCP core memory */
+	/* Unmap UCCP sysbus memory */
 	iounmap((void __iomem *)hpriv->uccp_sysbus_base_addr);
 	release_mem_region(hpriv->uccp_sysbus_base, hpriv->uccp_sysbus_len);
 
@@ -1258,15 +1260,28 @@ static int cleanup_all_resources(void)
 	release_mem_region(hpriv->uccp_perip_base, hpriv->uccp_perip_len);
 
 	/* Unmap GRAM */
+	if (hpriv->gram_b4_addr)
+		iounmap((void __iomem *)hpriv->gram_b4_addr);
+	if (hpriv->uccp_gram_base) {
+		release_mem_region(hpriv->uccp_gram_base,
+				   hpriv->uccp_gram_len);
+	}
 	iounmap((void __iomem *)hpriv->gram_base_addr);
 	release_mem_region(hpriv->uccp_pkd_gram_base,
 			   hpriv->uccp_pkd_gram_len);
 
-	/* Unmap UCCP Host RAM */
+	/* Free UCCP Host RAM */
 	kfree(hpriv->base_addr_uccp_host_ram);
 	hpriv->base_addr_uccp_host_ram = NULL;
 
+	/* Free UCCP HAL TX data */
+	kfree(hpriv->hal_tx_data);
+	hpriv->hal_tx_data = NULL;
+
+	/* Free private structure */
 	kfree(hpriv);
+	hpriv = NULL;
+
 	return 0;
 }
 
@@ -1487,24 +1502,19 @@ static int hal_init(void *dev)
 				 "uccp"))) {
 		pr_err("%s: request_mem_region failed for UCCP core region\n",
 		       hal_name);
-
-		kfree(hpriv);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto free_hpriv;
 	}
 
 	hpriv->uccp_sysbus_base_addr = (unsigned long)devm_ioremap(dev,
 							hpriv->uccp_sysbus_base,
 							hpriv->uccp_sysbus_len);
 
-	if (hpriv->uccp_sysbus_base_addr == 0) {
+	if (!hpriv->uccp_sysbus_base_addr) {
 		pr_err("%s: Ioremap failed for UCCP core mem region\n",
 			hal_name);
-
-		release_mem_region(hpriv->uccp_sysbus_base,
-				   hpriv->uccp_sysbus_len);
-		kfree(hpriv);
-
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto uccp_sysbus_release;
 	}
 
 	hpriv->uccp_mem_addr = hpriv->uccp_sysbus_base_addr +
@@ -1516,27 +1526,19 @@ static int hal_init(void *dev)
 				 "uccp"))) {
 		pr_err("%s: request_mem_region failed for UCCP perip region\n",
 		       hal_name);
-
-		kfree(hpriv);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto uccp_sysbus_unmap;
 	}
 
 	hpriv->uccp_perip_base_addr =
 	(unsigned long) devm_ioremap(dev, hpriv->uccp_perip_base,
 				     hpriv->uccp_perip_len);
 
-	if (hpriv->uccp_perip_base_addr == 0) {
+	if (!hpriv->uccp_perip_base_addr) {
 		pr_err("%s: Ioremap failed for UCCP perip mem region\n",
 			hal_name);
-
-		iounmap((void __iomem *)hpriv->uccp_sysbus_base_addr);
-		release_mem_region(hpriv->uccp_sysbus_base,
-				   hpriv->uccp_sysbus_len);
-		release_mem_region(hpriv->uccp_perip_base,
-				   hpriv->uccp_perip_len);
-		kfree(hpriv);
-
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto uccp_perip_release;
 	}
 
 	/* Map GRAM */
@@ -1545,59 +1547,41 @@ static int hal_init(void *dev)
 				"wlan_gram")) {
 		pr_err("%s: request_mem_region failed for GRAM\n",
 		       hal_name);
-
-		iounmap((void __iomem *)hpriv->uccp_sysbus_base_addr);
-		release_mem_region(hpriv->uccp_sysbus_base,
-				   hpriv->uccp_sysbus_len);
-
-		kfree(hpriv);
-
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto uccp_perip_unmap;
 	}
 
 	hpriv->gram_base_addr =
 		(unsigned long)devm_ioremap(dev, hpriv->uccp_pkd_gram_base,
 				       hpriv->uccp_pkd_gram_len);
-	if (hpriv->gram_base_addr == 0) {
-		pr_err("%s: Ioremap failed for g ram region.\n",
+	if (!hpriv->gram_base_addr) {
+		pr_err("%s: Ioremap failed for gram region.\n",
 		       hal_name);
-
-		iounmap((void __iomem *)hpriv->uccp_sysbus_base_addr);
-		release_mem_region(hpriv->uccp_sysbus_base,
-				   hpriv->uccp_sysbus_len);
-		release_mem_region(hpriv->uccp_pkd_gram_base,
-				   hpriv->uccp_pkd_gram_len);
-
-		kfree(hpriv);
-
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto uccp_gram_pkd_release;
 	}
 
 	hpriv->gram_mem_addr = hpriv->gram_base_addr + hpriv->shm_offset;
 
+	/* Try GFP_DMA, to get the buffer in ZONE_DMA.
+	 */
 	hpriv->base_addr_uccp_host_ram = kmalloc(HAL_HOST_BOUNCE_BUF_LEN,
-						 GFP_KERNEL);
+						 GFP_DMA);
 
 	if (!hpriv->base_addr_uccp_host_ram) {
-		iounmap((void __iomem *)hpriv->uccp_sysbus_base_addr);
-		release_mem_region(hpriv->uccp_sysbus_base,
-				   hpriv->uccp_sysbus_len);
-
-		iounmap((void __iomem *)hpriv->gram_base_addr);
-		release_mem_region(hpriv->uccp_pkd_gram_base,
-				   hpriv->uccp_pkd_gram_len);
-
-		kfree(hpriv);
-
-		return -ENOMEM;
+		pr_err("%s: uccp host ram: failed to allocate memory\n",
+			       hal_name);
+		err = -ENOMEM;
+		goto uccp_gram_unmap;
 	}
 
 	phys_64mb = virt_to_phys(hpriv->base_addr_uccp_host_ram);
 
-	UCCP_DEBUG_HAL("%s: kmalloc success: %p an phy: 0x%x\n",
-		 __func__,
-		 hpriv->base_addr_uccp_host_ram,
-		 phys_64mb);
+	pr_err("%s: kmalloc success: %p an phy: 0x%x end: %p\n",
+	       __func__,
+	       hpriv->base_addr_uccp_host_ram,
+	       phys_64mb,
+	       hpriv->base_addr_uccp_host_ram + HAL_HOST_ZONE_DMA_LEN);
 
 	/* Program the 64MB base address to the RPU.
 	 * RPU can access only 64MB starting from this
@@ -1613,6 +1597,7 @@ static int hal_init(void *dev)
 	value = value << 10;
 	writel(value, rpusocwrap + 0x218);
 
+	pr_err("%s: kmalloc success: %x\n", __func__, uccp_ddr_base);
 
 	if (hpriv->uccp_gram_base) {
 
@@ -1622,24 +1607,19 @@ static int hal_init(void *dev)
 				 "uccp_gram_base"))) {
 			pr_err("%s:uccp_gram_base: request_mem_region failed\n",
 			       hal_name);
-
-			kfree(hpriv);
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto free_host_ram;
 		}
 
 		hpriv->gram_b4_addr =
 			(unsigned long)devm_ioremap(dev, hpriv->uccp_gram_base,
 					       hpriv->uccp_gram_len);
 
-		if (hpriv->gram_b4_addr == 0) {
+		if (!hpriv->gram_b4_addr) {
 			pr_err("%s: Ioremap failed for UCCP mem region\n",
 				hal_name);
-
-			release_mem_region(hpriv->uccp_gram_base,
-					   hpriv->uccp_gram_len);
-			kfree(hpriv);
-
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto uccp_gram_release;
 		}
 	}
 
@@ -1647,17 +1627,20 @@ static int hal_init(void *dev)
 	if (chg_irq_register(1)) {
 		pr_err("%s: Unable to register Interrupt handler with kernel\n",
 		       hal_name);
-
-		cleanup_all_resources();
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto uccp_gram_b4_unmap;
 	}
 
 	/*Allocate space do update data pointers to DCP*/
 	hpriv->hal_tx_data = kzalloc((NUM_TX_DESC * NUM_FRAMES_IN_TX_DESC *
 				      sizeof(struct hal_tx_data)), GFP_KERNEL);
 
-	if (!hpriv->hal_tx_data)
-		return -ENOMEM;
+	if (!hpriv->hal_tx_data) {
+		pr_err("%s: hal_tx_data: unable to allocate memory\n",
+		       hal_name);
+		err = -ENOMEM;
+		goto uccp_gram_b4_unmap;
+	}
 
 	/* Intialize HAL tasklets */
 	tasklet_init(&hpriv->tx_tasklet,
@@ -1689,10 +1672,40 @@ static int hal_init(void *dev)
 
 	hpriv->cmd_cnt = COMMAND_START_MAGIC;
 	hpriv->event_cnt = 0;
+
 	return 0;
 
-}
+uccp_gram_b4_unmap:
+	if (hpriv->gram_b4_addr)
+		iounmap((void __iomem *)hpriv->gram_b4_addr);
+uccp_gram_release:
+	if (hpriv->uccp_gram_base)
+		release_mem_region(hpriv->uccp_gram_base,
+				   hpriv->uccp_gram_len);
+free_host_ram:
+	kfree(hpriv->base_addr_uccp_host_ram);
+	hpriv->base_addr_uccp_host_ram = NULL;
+uccp_gram_unmap:
+	iounmap((void __iomem *)hpriv->gram_base_addr);
+uccp_gram_pkd_release:
+	release_mem_region(hpriv->uccp_pkd_gram_base,
+			   hpriv->uccp_pkd_gram_len);
+uccp_perip_unmap:
+	iounmap((void __iomem *)hpriv->uccp_perip_base_addr);
+uccp_perip_release:
+	release_mem_region(hpriv->uccp_perip_base,
+			   hpriv->uccp_perip_len);
+uccp_sysbus_unmap:
+	iounmap((void __iomem *)hpriv->uccp_sysbus_base_addr);
+uccp_sysbus_release:
+	release_mem_region(hpriv->uccp_sysbus_base,
+			   hpriv->uccp_sysbus_len);
+free_hpriv:
+	kfree(hpriv);
+	hpriv = NULL;
 
+	return err;
+}
 
 static void hal_deinit_bufs(void)
 {
@@ -1802,18 +1815,21 @@ static int hal_init_bufs(unsigned int tx_bufs,
 		goto err;
 	}
 
-	rx_max_data_size = MAX_DATA_SIZE_2K;
 
 	for (cmd_count = 0; cmd_count < cmd_buf_count; cmd_count++) {
 		memset(&cmd_rx, 0, sizeof(struct cmd_hal));
 
-		UCCP_DEBUG_HAL("%s: Loop :%d: rx_max_data_size: %d\n",
-			 hal_name, cmd_count, rx_max_data_size);
 
 		for (count = 0; count < MAX_RX_BUF_PTR_PER_CMD; count++,
 		     pkt_desc++) {
+
 			if (pkt_desc < hpriv->rx_bufs_12k)
 				rx_max_data_size = MAX_DATA_SIZE_12K;
+			else
+				rx_max_data_size = MAX_DATA_SIZE_2K;
+
+			UCCP_DEBUG_HAL("%s: Loop :%d: rx_max_data_size: %d\n",
+				 hal_name, cmd_count, rx_max_data_size);
 
 			result = init_rx_buf(pkt_desc,
 					     rx_max_data_size,
@@ -1911,8 +1927,11 @@ int hal_map_tx_buf(int pkt_desc, int frame_id, unsigned char *data, int len)
 			     (index * hpriv->max_data_size);
 
 		memcpy(tx_address, data, len);
-	} else
+		alloc_skb_priv_tx_region++;
+	} else {
 		tx_address = data;
+		alloc_skb_dma_region++;
+	}
 
 	dma_buf = dma_map_single(NULL,
 				 tx_address,
@@ -2039,7 +2058,7 @@ static int init_rx_buf(int pkt_desc,
 		}
 
 		hpriv->rx_buf_info[pkt_desc].dma_buf_priv = 1;
-		alloc_skb_priv_region++;
+		alloc_skb_priv_rx_region++;
 	}
 
 	*dma_buf = dma_map_single(NULL,
diff --git a/drivers/net/wireless/uccp420wlan/src/tx.c b/drivers/net/wireless/uccp420wlan/src/tx.c
index d883d0d..d281e23 100755
--- a/drivers/net/wireless/uccp420wlan/src/tx.c
+++ b/drivers/net/wireless/uccp420wlan/src/tx.c
@@ -90,13 +90,14 @@ static void update_aux_adc_voltage(struct mac80211_dev *dev,
 }
 
 static int check_80211_aggregation(struct mac80211_dev *dev,
-				   struct sk_buff *skb,
-				   int ac,
+				struct sk_buff *skb,
+			       int ac,
 #ifdef MULTI_CHAN_SUPPORT
-				   int off_chanctx_idx,
+			       int off_chanctx_idx,
 #endif
-				   int peer_id)
+			       int peer_id)
 {
+
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *mac_hdr = NULL, *mac_hdr_first = NULL;
 	struct sk_buff *skb_first;
@@ -155,6 +156,7 @@ static int check_80211_aggregation(struct mac80211_dev *dev,
 	return (ampdu && is_qos && addr);
 }
 
+
 static void tx_status(struct sk_buff *skb,
 		      struct umac_event_tx_done *tx_done,
 		      unsigned int frame_idx,
@@ -170,9 +172,17 @@ static void tx_status(struct sk_buff *skb,
 	int tx_fixed_rate = 0;
 	struct ieee80211_supported_band *band = NULL;
 	struct umac_vif *uvif = NULL;
+	int ret = 0;
 
 	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
 
+	/*Just inform ma8c0211, it will free the skb*/
+	if (tx_done->frm_status[frame_idx] == TX_DONE_STAT_DISCARD) {
+		ieee80211_free_txskb(dev->hw, skb);
+		dev->stats->tx_dones_to_stack++;
+		return;
+	}
+
 	/* Rate info will be retained, except the count*/
 	ieee80211_tx_info_clear_status(tx_info);
 
@@ -287,7 +297,7 @@ static void tx_status(struct sk_buff *skb,
 			atomic_read(&dev->roc_params.roc_mgmt_tx_count));
 		if (dev->roc_params.roc_in_progress &&
 		    dev->roc_params.roc_type == ROC_TYPE_OFFCHANNEL_TX) {
-			uccp420wlan_prog_roc(ROC_STOP, 0, 0, 0);
+			CALL_UMAC(uccp420wlan_prog_roc, ROC_STOP, 0, 0, 0);
 			UCCP_DEBUG_ROC("%s:%d", __func__, __LINE__);
 			UCCP_DEBUG_ROC("all offchan pending frames cleared\n");
 		}
@@ -296,6 +306,8 @@ static void tx_status(struct sk_buff *skb,
 	dev->stats->tx_dones_to_stack++;
 
 	ieee80211_tx_status(dev->hw, skb);
+prog_umac_fail:
+	return;
 }
 
 
@@ -352,6 +364,7 @@ void free_token(struct mac80211_dev *dev,
 	int pool_id = -1;
 	int test = 0;
 	unsigned int old_token = tx->outstanding_tokens[queue];
+
 	bit = (token_id % TX_DESC_BUCKET_BOUND);
 	pool_id = (token_id / TX_DESC_BUCKET_BOUND);
 
@@ -625,12 +638,12 @@ void uccp420wlan_tx_proc_send_pend_frms_all(struct mac80211_dev *dev,
 					     ch_id,
 					     0,
 					     0); /* TODO: Currently sending 0
-						    since this param is not used
-						    as expected in the orig
-						    code for multiple frames etc
-						    Need to set this
-						    properly when the orig code
-						    logic is corrected
+						  * since this param is not used
+						  * as expected in the orig
+						  * code for multiple frames etc
+						  * Need to set this
+						  * properly when the orig code
+						  * logic is corrected
 						  */
 		if (ret < 0) {
 			pr_err("%s: Queueing of TX frame to FW failed\n",
@@ -664,6 +677,8 @@ int uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 	int pend_pkt_q_len = 0;
 	struct curr_peer_info peer_info;
 	int loop_cnt = 0;
+	struct tx_pkt_info *pkt_info = NULL;
+
 	peer_info = get_curr_peer_opp(dev,
 #ifdef MULTI_CHAN_SUPPORT
 				       curr_chanctx_idx,
@@ -682,10 +697,11 @@ int uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 #endif
 
 #ifdef MULTI_CHAN_SUPPORT
-	txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
+	pkt_info = &dev->tx.pkt_info[curr_chanctx_idx][token_id];
 #else
-	txq = &dev->tx.pkt_info[token_id].pkt;
+	pkt_info = &dev->tx.pkt_info[token_id];
 #endif
+	txq = &pkt_info->pkt;
 
 
 	/* Aggregate Only MPDU's with same RA, same Rate,
@@ -713,7 +729,7 @@ int uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 		if (!check_80211_aggregation(dev,
 					     loop_skb,
 					     ac,
-					     curr_chanctx_idx,
+					     peer_info.op_chan_idx,
 					     peer_info.id) ||
 		    (skb_queue_len(txq) >= max_tx_cmds)) {
 			break;
@@ -739,6 +755,7 @@ int uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 		tx->queue_stopped_bmp &= ~(1 << (ac));
 	}
 
+	pkt_info->peer_id = peer_info.id;
 	UCCP_DEBUG_TX("%s-UMACTX: token_id: %d ",
 				dev->name,
 				token_id);
@@ -763,9 +780,8 @@ int uccp420wlan_tx_alloc_token(struct mac80211_dev *dev,
 	struct sk_buff_head *pend_pkt_q = NULL;
 	unsigned int pkts_pend = 0;
 	struct ieee80211_tx_info *tx_info;
-	unsigned int pend_q_len = 0;
-	spin_lock_bh(&tx->lock);
 
+	spin_lock_bh(&tx->lock);
 #ifdef MULTI_CHAN_SUPPORT
 	pend_pkt_q = &tx->pending_pkt[off_chanctx_idx][peer_id][ac];
 
@@ -773,40 +789,43 @@ int uccp420wlan_tx_alloc_token(struct mac80211_dev *dev,
 	pend_pkt_q = &tx->pending_pkt[peer_id][ac];
 #endif
 #ifdef MULTI_CHAN_SUPPORT
-	UCCP_DEBUG_TX("%s-UMACTX:Alloc buf Req q = %d off_chan: %d\n",
-					dev->name,
-					ac,
-					off_chanctx_idx);
+	UCCP_DEBUG_TX("%s-UMACTX:Alloc Req q = %d off_chan: %d out_tok:%d\n",
+		      dev->name,
+		      ac,
+		      off_chanctx_idx, tx->outstanding_tokens[ac]);
 #else
 	UCCP_DEBUG_TX("%s-UMACTX:Alloc buf Req q = %d\n",
-					dev->name,
-					ac);
+		      dev->name,
+		      ac);
 #endif
 	UCCP_DEBUG_TX("peerid: %d,\n", peer_id);
 
 	/* Queue the frame to the pending frames queue */
 	skb_queue_tail(pend_pkt_q, skb);
-	pend_q_len = skb_queue_len(pend_pkt_q);
 
 	tx_info = IEEE80211_SKB_CB(skb);
 
 	if (tx->outstanding_tokens[ac] >= NUM_TX_DESCS_PER_AC) {
-		bool agg_status = check_80211_aggregation(dev,
-						      skb,
-						      ac,
-						      off_chanctx_idx,
-						      peer_id);
+		bool agg_status = false;
+
+		agg_status = check_80211_aggregation(dev,
+						     skb,
+						     ac,
+						     off_chanctx_idx,
+						     peer_id);
 
 		if (agg_status || !dev->params->enable_early_agg_checks) {
+			int max_cmds = dev->params->max_tx_cmds;
+
 			/* encourage aggregation to the max size
 			 * supported (dev->params->max_tx_cmds)
 			 */
-			if (pend_q_len < dev->params->max_tx_cmds) {
-				UCCP_DEBUG_TX("tx:pend_q not full out_tok:%d\n",
+			if (skb_queue_len(pend_pkt_q) < max_cmds) {
+				UCCP_DEBUG_TX("pend_q not full out_tok:%d\n",
 					      tx->outstanding_tokens[ac]);
 				goto out;
 			 } else {
-				UCCP_DEBUG_TX("tx:pend_q full out_tok:%d\n",
+				UCCP_DEBUG_TX("pend_q full out_tok:%d\n",
 					      tx->outstanding_tokens[ac]);
 			}
 		}
@@ -819,7 +838,7 @@ int uccp420wlan_tx_alloc_token(struct mac80211_dev *dev,
 	 * the shared ROC queue (which is VO right now), since this would block
 	 * ROC traffic too.
 	 */
-	if (pend_q_len >= MAX_TX_QUEUE_LEN) {
+	if (skb_queue_len(pend_pkt_q) >= MAX_TX_QUEUE_LEN) {
 		if ((!dev->roc_params.roc_in_progress) ||
 		    (dev->roc_params.roc_in_progress &&
 		     (ac != UMAC_ROC_AC))) {
@@ -835,10 +854,10 @@ int uccp420wlan_tx_alloc_token(struct mac80211_dev *dev,
 #endif
 			     ac);
 
-	UCCP_DEBUG_TX("%s-UMACTX:Alloc buf Result *id= %d q = %d",
+	UCCP_DEBUG_TX("%s-UMACTX:Alloc buf Result *id= %d q = %d out_tok: %d",
 					dev->name,
 					token_id,
-					ac);
+					ac, tx->outstanding_tokens[ac]);
 	UCCP_DEBUG_TX(", peerid: %d,\n", peer_id);
 
 	if (token_id == NUM_TX_DESCS)
@@ -925,11 +944,11 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	chanctx_idx = tx->desc_chan_map[desc_id];
 	if (chanctx_idx == -1) {
 		spin_unlock_bh(&tx->lock);
-		pr_err("%s: Unexpected channel context:tok:%d q:%d\n",
-		       __func__,
-		       desc_id,
-		       tx_done->queue);
-		free_token(dev, desc_id, tx_done->queue);
+		if (net_ratelimit())
+			pr_err("%s: Unexpected channel context:tok:%d q:%d\n",
+			       __func__,
+			       desc_id,
+			       tx_done->queue);
 		goto out;
 	}
 	pkt_info = &dev->tx.pkt_info[chanctx_idx][desc_id];
@@ -1067,6 +1086,8 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 				  dev,
 				  tx_info_1st_mpdu);
 		} else {
+			struct ieee80211_bss_conf *bss_conf;
+			bool bcn_status;
 
 			if (tx_done->frm_status[pkt] ==
 			    TX_DONE_STAT_DISCARD_BCN) {
@@ -1081,52 +1102,54 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 			tx_info_bcn = IEEE80211_SKB_CB(skb);
 			ivif = tx_info_bcn->control.vif;
 			uvif = (struct umac_vif *)(ivif->drv_priv);
-			bcn_int = uvif->vif->bss_conf.beacon_int - 10;
+
+			bss_conf = &uvif->vif->bss_conf;
+			bcn_status = bss_conf->enable_beacon;
+			bcn_int = bss_conf->beacon_int - 10;
 			bcn_int = msecs_to_jiffies(bcn_int);
 
+			for (i = 0; i < MAX_VIFS; i++) {
+				if (dev->active_vifs & (1 << i)) {
+					if ((dev->vifs[i] == ivif) &&
+					    (bcn_status == true)) {
+						mod_timer(&uvif->bcn_timer,
+							  jiffies +
+							  bcn_int);
+					}
+				}
+			}
+
 			/* Beacon Time Stamp */
 			if (tx_done->frm_status[pkt] == TX_DONE_STAT_SUCCESS) {
 				unsigned int ts2;
 				unsigned int ldelta = 0;
 				int ets_band;
 				int bts_vif = uvif->vif_index;
-
+				struct wifi_sync sync =
+						dev->params->sync[bts_vif];
 #ifdef MULTI_CHAN_SUPPORT
 				ets_band = get_band_chanctx(dev, uvif);
 #endif
 				spin_lock(&tsf_lock);
-				dev->params->sync[bts_vif].status = 1;
-				memcpy(dev->params->sync[bts_vif].bssid,
-					ivif->bss_conf.bssid, ETH_ALEN);
-				memcpy(dev->params->sync[bts_vif].ts1,
-					tx_done->reserved, 8);
-				memcpy(&dev->params->sync[bts_vif].ts2,
-					(tx_done->reserved + 8), 4);
-				ts2 = dev->params->sync[bts_vif].ts2;
-				dev->params->sync[bts_vif].atu = 0;
-
-				if (IEEE80211_BAND_2GHZ == ets_band)
+				sync.status = 1;
+				ether_addr_copy(sync.bssid,
+					ivif->bss_conf.bssid);
+				memcpy(sync.ts1, tx_done->reserved, 8);
+				memcpy(&sync.ts2, (tx_done->reserved + 8), 4);
+				ts2 = sync.ts2;
+				sync.atu = 0;
+
+				if (ets_band == IEEE80211_BAND_2GHZ)
 					ldelta = BTS_AP_24GHZ_ETS;
-				else if (IEEE80211_BAND_5GHZ == ets_band)
+				else if (ets_band == IEEE80211_BAND_5GHZ)
 					ldelta = BTS_AP_5GHZ_ETS;
 
 				if (frc_to_atu) {
-					frc_to_atu(ts2,
-					&dev->params->sync[bts_vif].atu, 0);
-				dev->params->sync[bts_vif].atu += ldelta * 1000;
+					frc_to_atu(ts2, &sync.atu, 0);
+					sync.atu += ldelta * 1000;
 				}
 				spin_unlock(&tsf_lock);
 			}
-
-			for (i = 0; i < MAX_VIFS; i++) {
-				if (dev->active_vifs & (1 << i)) {
-					if (dev->vifs[i] == ivif)
-						mod_timer(&uvif->bcn_timer,
-							  jiffies +
-							  bcn_int);
-				}
-			}
-
 			dev_kfree_skb_any(skb);
 		}
 
@@ -1300,6 +1323,7 @@ unsigned int uccp420wlan_proc_tx_dscrd_chsw(struct mac80211_dev *dev,
 			if (!skb)
 				continue;
 			skb_queue_tail(&tx_done_list, skb);
+
 			UCCP_DEBUG_TX("%s: %d ", __func__, __LINE__);
 			UCCP_DEBUG_TX("Freeing the skb MAX retries reached.\n");
 		} else {
@@ -1410,12 +1434,13 @@ tx_done:
 	}
 
 	spin_lock_bh(&tx->lock);
-out:
+
 	if (!pkts_pend) {
 		/* Mark the token as available */
 		free_token(dev, desc_id, tx_done->queue);
 		dev->tx.desc_chan_map[desc_id] = -1;
 	}
+out:
 	spin_unlock_bh(&tx->lock);
 
 	return pkts_pend;
@@ -1649,6 +1674,7 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 #endif
 
 	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
+	mac_hdr = (struct ieee80211_hdr *)(skb->data);
 
 	if (sta) {
 		usta = (struct umac_sta *)sta->drv_priv;
@@ -1660,13 +1686,14 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 	if (bcast == false) {
 		queue = tx_queue_map(skb->queue_mapping);
 		more_frames = 0;
-		dev->stats->tx_cmds_from_stack++;
 	} else {
 		queue = WLAN_AC_BCN;
 		/* Hack: skb->priority is used to indicate more frames */
 		more_frames = skb->priority;
 	}
 
+	if (!ieee80211_is_beacon(mac_hdr->frame_control))
+		dev->stats->tx_cmds_from_stack++;
 
 	if (dev->params->production_test == 1)
 		tx_info->flags |= IEEE80211_TX_CTL_AMPDU;
@@ -1685,16 +1712,16 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 	}
 #endif
 
-	mac_hdr = (struct ieee80211_hdr *)(skb->data);
 
 	UCCP_DEBUG_TX("%s-UMACTX:%s:%d ",
 			dev->name,
 			 __func__,
 			 __LINE__);
-	UCCP_DEBUG_TX("Waiting for Allocation:queue: %d qmap: %d is_bcn: %d\n",
+	UCCP_DEBUG_TX("Wait Alloc:queue: %d qmap: %d is_bcn: %d bcast:%d\n",
 			queue,
 			skb->queue_mapping,
-			ieee80211_is_beacon(mac_hdr->frame_control));
+			ieee80211_is_beacon(mac_hdr->frame_control),
+			is_multicast_ether_addr(mac_hdr->addr1) ? true : false);
 
 	token_id = uccp420wlan_tx_alloc_token(dev,
 						 queue,
@@ -1850,8 +1877,36 @@ out:
 	}
 }
 
-
 #ifdef MULTI_CHAN_SUPPORT
+void uccp420_purge_tx_queue(struct mac80211_dev *dev,
+			   struct sk_buff_head *skbs)
+{
+
+
+	struct sk_buff *loop_skb = NULL, *tmp = NULL;
+
+	skb_queue_walk_safe(skbs,
+			    loop_skb,
+			    tmp) {
+		struct ieee80211_hdr *hdr = NULL;
+
+		__skb_unlink(loop_skb,
+			     skbs);
+
+		if (!loop_skb)
+			continue;
+
+		hdr = (struct ieee80211_hdr *)loop_skb->data;
+
+		if (!ieee80211_is_beacon(hdr->frame_control))
+			dev->stats->tx_dones_to_stack++;
+
+		ieee80211_free_txskb(dev->hw,
+				     loop_skb);
+	}
+
+}
+
 static int uccp420_flush_vif_all_pend_q(struct mac80211_dev *dev,
 					struct umac_vif *uvif,
 					unsigned int hw_queue_map,
@@ -1859,7 +1914,6 @@ static int uccp420_flush_vif_all_pend_q(struct mac80211_dev *dev,
 {
 	unsigned int pending = 0;
 	int count = 0;
-	int peer_id = -1;
 	unsigned int queue = 0;
 	int pend_q = 0;
 	struct sk_buff_head *pend_pkt_q = NULL;
@@ -1870,21 +1924,19 @@ static int uccp420_flush_vif_all_pend_q(struct mac80211_dev *dev,
 
 	tx = &dev->tx;
 
-#ifdef MULTI_CHAN_SUPPORT
 	if (!uvif->chanctx) {
-		UCCP_DEBUG_TSMC("%s: Chanctx NULL, returning\n",
+		UCCP_DEBUG_TX("%s: Chanctx NULL, returning\n",
 						__func__);
 		return -1;
 	}
-#endif
 
 	for (queue = 0; queue < NUM_ACS; queue++) {
 		if (!(BIT(queue) & hw_queue_map))
 			continue;
 
 		for (pend_q = 0; pend_q < MAX_PEND_Q_PER_AC; pend_q++) {
+			rcu_read_lock();
 			if (pend_q < MAX_PEERS) {
-				rcu_read_lock();
 				sta = rcu_dereference(dev->peers[pend_q]);
 
 				if (!sta) {
@@ -1894,25 +1946,42 @@ static int uccp420_flush_vif_all_pend_q(struct mac80211_dev *dev,
 
 				usta = (struct umac_sta *)(sta->drv_priv);
 
-				if (usta->vif_index == uvif->vif_index)
-					peer_id = pend_q;
-				else {
+				if (usta->vif_index != uvif->vif_index) {
+					rcu_read_unlock();
+					continue;
+				}
+				rcu_read_unlock();
+			} else if (pend_q >= MAX_PEERS) {
+				int vif_index;
+				struct umac_vif *tvif;
+				struct ieee80211_vif *vif = NULL;
+
+				vif_index = pend_q - MAX_PEERS;
+				vif = rcu_dereference(dev->vifs[vif_index]);
+
+				if (!vif) {
 					rcu_read_unlock();
 					continue;
 				}
 
+				tvif = (struct umac_vif *)(vif->drv_priv);
+
+				if (uvif->vif_index != tvif->vif_index) {
+					rcu_read_unlock();
+					continue;
+				}
+				rcu_read_unlock();
+			} else {
 				rcu_read_unlock();
-			} else if (pend_q == uvif->vif_index)
-				peer_id = uvif->vif_index;
-			else
 				continue;
+			}
 
 			while (1) {
 				spin_lock_bh(&tx->lock);
 
 				pend_pkt_q =
 					&tx->pending_pkt[chanctx_type]
-							[peer_id]
+							[pend_q]
 							[queue];
 
 				/* Assuming all packets for the peer have same
@@ -1927,18 +1996,19 @@ static int uccp420_flush_vif_all_pend_q(struct mac80211_dev *dev,
 
 				if (!warned &&
 				    count >= QUEUE_FLUSH_TIMEOUT_TICKS) {
-					pr_err("%s: Timeout: VIF: %d Queue: %d pending: %d: LMAC probably STUCK\n",
+					pr_err("%s: Timeout: VIF: %d Queue: %d pending: %d\n",
 					       dev->name,
 					       uvif->vif_index,
 					       queue,
 					       pending);
 					WARN_ON(1);
 					warned = true;
+					return -1;
 				}
 
 				current->state = TASK_INTERRUPTIBLE;
 
-				if (0 == schedule_timeout(1))
+				if (schedule_timeout(1) == 0)
 					count++;
 
 			}
@@ -1956,16 +2026,160 @@ static int uccp420_flush_vif_all_pend_q(struct mac80211_dev *dev,
 		}
 	}
 
-	UCCP_DEBUG_TSMC("%s: Success for VIF: %d and Queue: %d\n",
+	UCCP_DEBUG_TX("%s: Success for VIF: %d and Queue: %d\n",
 					__func__,
 					uvif->vif_index,
 					queue);
 	return 0;
 }
-#endif
 
+int uccp420_discard_sta_pend_q(struct mac80211_dev *dev,
+				   struct umac_vif *uvif,
+				   int peer_id,
+				   unsigned int hw_queue_map)
+{
+	unsigned int pending = 0;
+	unsigned int queue = 0;
+	int pend_q = 0;
+	struct sk_buff_head *pend_pkt_q = NULL, tx_discard_list;
+	struct tx_config *tx = &dev->tx;
+
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d hqmap:%d vif:%d\n",
+		      __func__,
+		      __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack,
+		      hw_queue_map,
+		      uvif->vif_index);
+	skb_queue_head_init(&tx_discard_list);
 
-#ifdef MULTI_CHAN_SUPPORT
+	for (queue = 0; queue < NUM_ACS; queue++) {
+
+		if (!(BIT(queue) & hw_queue_map))
+			continue;
+
+		UCCP_DEBUG_TX("%s:%d MATCH queue: %d pend_q:%d\n",
+			      __func__,
+			      __LINE__,
+			      queue,
+			      pend_q);
+
+		pend_pkt_q =
+			&tx->pending_pkt[0]
+					[peer_id]
+					[queue];
+
+		pending = skb_queue_len(pend_pkt_q);
+
+		if (!pending)
+			continue;
+
+		UCCP_DEBUG_TX("%s:%d Free the skbs..\n",
+			      __func__,
+			      __LINE__);
+
+		skb_queue_splice_tail_init(pend_pkt_q,
+					   &tx_discard_list);
+		uccp420_purge_tx_queue(dev, &tx_discard_list);
+
+	}
+	UCCP_DEBUG_TX("%s:%d Exit..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
+	return 0;
+}
+
+int uccp420_discard_sta_tx_q(struct mac80211_dev *dev,
+				   struct umac_vif *uvif,
+				   int peer_id,
+				   unsigned int hw_queue_map,
+				   int chanctx_idx)
+{
+	struct tx_config *tx = &dev->tx;
+	struct tx_pkt_info *pkt_info = NULL;
+	struct sk_buff_head *txq = NULL;
+	struct sk_buff *loop_skb = NULL, *tmp = NULL;
+	int i = 0, pkt;
+
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d hqmap:%d vif:%d\n",
+		      __func__,
+		      __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack,
+		      hw_queue_map,
+		      uvif->vif_index);
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		pkt_info = &tx->pkt_info[chanctx_idx][i];
+		UCCP_DEBUG_TX("%s:%d pvif: %d uvif:%d q:%d hq:%d peer_id:%d\n",
+			      __func__,
+			      __LINE__,
+			      pkt_info->vif_index,
+			      uvif->vif_index,
+			      pkt_info->queue,
+			      hw_queue_map,
+			      peer_id);
+
+		if ((pkt_info->vif_index == uvif->vif_index) &&
+		    ((peer_id == -1) || (pkt_info->peer_id == peer_id)) &&
+		    (BIT(pkt_info->queue) & hw_queue_map)) {
+			int pool_id = i/TX_DESC_BUCKET_BOUND;
+
+			txq = &pkt_info->pkt;
+
+			if (!skb_queue_len(txq) ||
+			    !test_bit(i, &tx->buf_pool_bmp[pool_id]))
+				continue;
+
+			UCCP_DEBUG_TX("%s: Free the skbs:%d\n", __func__, i);
+
+
+			/* In the Tx path we move the .11hdr from skb to CMD_TX
+			 * Hence pushing it here, not required for loopback case
+			 */
+			pkt = 0;
+			skb_queue_walk_safe(txq,
+					    loop_skb,
+					    tmp) {
+				skb_push(loop_skb, pkt_info->hdr_len);
+				hal_ops.unmap_tx_buf(i, pkt);
+				pkt++;
+			}
+			uccp420_purge_tx_queue(dev, txq);
+			free_token(dev, i, pkt_info->queue);
+			dev->tx.desc_chan_map[i] = -1;
+		}
+	}
+	UCCP_DEBUG_TX("%s:%d Exit..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
+	return 0;
+}
+static int uccp420_discard_vif_tx_queues(struct mac80211_dev *dev,
+				       struct umac_vif *uvif,
+				       int chanctx_idx,
+				       unsigned int hw_queue_map)
+{
+	struct tx_config *tx = NULL;
+
+	tx = &dev->tx;
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
+	spin_lock_bh(&tx->lock);
+	uccp420_discard_sta_tx_q(dev, uvif, -1, hw_queue_map, chanctx_idx);
+	spin_unlock_bh(&tx->lock);
+
+
+	UCCP_DEBUG_TX("%s: Success for VIF: %d",
+					__func__,
+					uvif->vif_index);
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
+	return 0;
+
+}
 static int uccp420_flush_vif_tx_queues(struct mac80211_dev *dev,
 				       struct umac_vif *uvif,
 				       int chanctx_idx,
@@ -2006,50 +2220,157 @@ static int uccp420_flush_vif_tx_queues(struct mac80211_dev *dev,
 
 		if (!warned &&
 		    count >= QUEUE_FLUSH_TIMEOUT_TICKS) {
-			pr_err("%s-UMACTX: Failed for VIF: %d, buf_pool_bmp : 0x%lx: LMAC probably STUCK\n",
+			pr_err("%s-UMACTX: TXQ: Failed for VIF: %d, buf_pool_bmp : 0x%lx:\n",
 			       dev->name,
 			       uvif->vif_index,
 			       buf_pool_bmp);
 			WARN_ON(1);
 			warned = true;
+			return -1;
 		}
 
 		current->state = TASK_INTERRUPTIBLE;
 
-		if (0 == schedule_timeout(1))
+		if (schedule_timeout(1) == 0)
 			count++;
 	}
 
-	UCCP_DEBUG_TSMC("%s: Success for VIF: %d, buf_pool_bmp : 0x%lx\n",
+	UCCP_DEBUG_TX("%s: Success for VIF: %d, buf_pool_bmp : 0x%lx\n",
 					__func__,
 					uvif->vif_index,
 					buf_pool_bmp);
 	return 0;
 }
-#endif
+int uccp420_discard_vif_all_pend_q(struct mac80211_dev *dev,
+				   struct umac_vif *uvif,
+				   unsigned int hw_queue_map)
+{
+	struct tx_config *tx = &dev->tx;
+	struct ieee80211_sta *sta = NULL;
+	struct umac_sta *usta = NULL;
+	unsigned int pend_q;
+
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d hqmap:%d vif:%d\n",
+		      __func__,
+		      __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack,
+		      hw_queue_map,
+		      uvif->vif_index);
+	spin_lock_bh(&tx->lock);
 
+	for (pend_q = 0; pend_q < MAX_PEND_Q_PER_AC; pend_q++) {
+		rcu_read_lock();
+		if (pend_q < MAX_PEERS) {
+			sta = rcu_dereference(dev->peers[pend_q]);
+
+			if (!sta) {
+				rcu_read_unlock();
+				continue;
+			}
+
+			usta = (struct umac_sta *)(sta->drv_priv);
+
+			if (usta->vif_index != uvif->vif_index) {
+				rcu_read_unlock();
+				continue;
+			}
+		} else if (pend_q >= MAX_PEERS) {
+			int vif_index;
+			struct umac_vif *tvif;
+			struct ieee80211_vif *vif = NULL;
+
+			vif_index = pend_q - MAX_PEERS;
+			vif = rcu_dereference(dev->vifs[vif_index]);
+
+			if (!vif) {
+				rcu_read_unlock();
+				continue;
+			}
+
+			tvif = (struct umac_vif *)(vif->drv_priv);
+
+			if (uvif->vif_index != tvif->vif_index) {
+				rcu_read_unlock();
+				continue;
+			}
+		} else {
+			rcu_read_unlock();
+			continue;
+		}
+		rcu_read_unlock();
+		uccp420_discard_sta_pend_q(dev, uvif, pend_q, hw_queue_map);
+	}
+
+	spin_unlock_bh(&tx->lock);
+	UCCP_DEBUG_TX("%s:%d Exit..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
+	return 0;
+}
 
-#ifdef MULTI_CHAN_SUPPORT
 int uccp420_flush_vif_queues(struct mac80211_dev *dev,
 			     struct umac_vif *uvif,
 			     int chanctx_idx,
 			     unsigned int hw_queue_map,
-			     enum UMAC_VIF_CHANCTX_TYPE vif_chanctx_type)
+			     enum UMAC_VIF_CHANCTX_TYPE vif_chanctx_type,
+			     bool drop)
 {
 	int result  = -1;
+	char peer_addr[ETH_ALEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
+
+	if (drop) {
+		/*Discard: clear pend_q, send tx_deinit to LMAC*/
+		UCCP_DEBUG_TX("%s: DISCARD\n", __func__);
+		result = uccp420_discard_vif_all_pend_q(dev,
+						      uvif,
+						      hw_queue_map);
+		if (result)
+			return result;
+
+		dev->tx_deinit_complete = 0;
+		uccp420wlan_prog_tx_deinit(uvif->vif_index, peer_addr);
+		if (wait_for_tx_deinit_complete(dev) < 0) {
+			/*Stuck: Reload FW??*/
+			WARN_ON(1);
+			result = uccp420_discard_vif_tx_queues(dev,
+							       uvif,
+							       chanctx_idx,
+							       hw_queue_map);
+		}
+	} else {
+		UCCP_DEBUG_TX("%s: FLUSH\n", __func__);
+		/*Flush: Wait for frames*/
+		result = uccp420_flush_vif_all_pend_q(dev,
+						      uvif,
+						      hw_queue_map,
+						      vif_chanctx_type);
+
+		if (result == 0) {
+			result = uccp420_flush_vif_tx_queues(dev,
+							     uvif,
+							     chanctx_idx,
+							     hw_queue_map);
+		}
 
-	result = uccp420_flush_vif_all_pend_q(dev,
-					      uvif,
-					      hw_queue_map,
-					      vif_chanctx_type);
+		if (result) {
+			result = uccp420_discard_vif_all_pend_q(dev,
+								uvif,
+								hw_queue_map);
 
-	if (result == 0) {
-		result = uccp420_flush_vif_tx_queues(dev,
-						     uvif,
-						     chanctx_idx,
-						     hw_queue_map);
+			result = uccp420_discard_vif_tx_queues(dev,
+							     uvif,
+							     chanctx_idx,
+							     hw_queue_map);
+		}
 	}
-
+	UCCP_DEBUG_TX("%s:%d Enter..:tx:%d txd:%d\n", __func__, __LINE__,
+		      dev->stats->tx_cmds_from_stack,
+		      dev->stats->tx_dones_to_stack);
 	return result;
 }
 #endif
diff --git a/drivers/net/wireless/uccp420wlan/src/umac_if.c b/drivers/net/wireless/uccp420wlan/src/umac_if.c
index f561595..1f55bfb 100644
--- a/drivers/net/wireless/uccp420wlan/src/umac_if.c
+++ b/drivers/net/wireless/uccp420wlan/src/umac_if.c
@@ -22,24 +22,24 @@
  * USA.
  */
 
-#include <linux/spinlock.h>
+#include <linux/netdevice.h>
 #include <linux/rcupdate.h>
 #include <linux/slab.h>
-#include <linux/netdevice.h>
+#include <linux/spinlock.h>
 
-#include "umac_if.h"
 #include "core.h"
+#include "umac_if.h"
 
-#define UCCP_DEBUG_IF(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_IF)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_IF(fmt, ...)              \
+do {                                          \
+	if (uccp_debug & UCCP_DEBUG_IF)        \
+		pr_debug(fmt, ##__VA_ARGS__);   \
 } while (0)
 
-#define UCCP_DEBUG_FAIL_SAFE(fmt, ...)                           \
-do {                                                                    \
-		if (uccp_debug & UCCP_DEBUG_FAIL_SAFE)                       \
-			pr_debug(fmt, ##__VA_ARGS__);  \
+#define UCCP_DEBUG_FAIL_SAFE(fmt, ...)        \
+do {                                           \
+	if (uccp_debug & UCCP_DEBUG_FAIL_SAFE)  \
+		pr_debug(fmt, ##__VA_ARGS__);    \
 } while (0)
 
 unsigned char wildcard_ssid[7] = "DIRECT-";
@@ -159,32 +159,34 @@ static void get_rate(struct sk_buff *skb,
 		     struct mac80211_dev *dev)
 {
 	struct ieee80211_rate *rate;
-	struct ieee80211_tx_info *c;
-	unsigned int index;
+	struct ieee80211_tx_info *c = IEEE80211_SKB_CB(skb);
+	unsigned int index, min_rate;
 	bool is_mcs = false, is_mgd = false;
 	struct ieee80211_tx_rate *txrate;
 	unsigned char mcs_rate_num = 0;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
 	int mcs_indx;
 	int mgd_rate;
+	int mgd_mcast_rate;
 	int prot_type;
-
+	unsigned char nss = 1;
+	bool all_rates_invalid = true;
 	/* Normal Mode*/
-	rate = ieee80211_get_tx_rate(dev->hw, IEEE80211_SKB_CB(skb));
+	rate = ieee80211_get_tx_rate(dev->hw, c);
+	min_rate = dev->hw->wiphy->bands[c->band]->bitrates[0].hw_value;
 
 	if (rate == NULL) {
-		rate = &dev->hw->wiphy->bands[
-				dev->hw->conf.chandef.chan->band]->bitrates[0];
 		txcmd->num_rates = 1;
-		txcmd->rate[0] = rate->hw_value;
+		txcmd->rate[0] = min_rate;
 		txcmd->rate_retries[0] = 5;
 		txcmd->rate_protection_type[0] = USE_PROTECTION_NONE;
 		txcmd->rate_preamble_type[0] = DONT_USE_SHORT_PREAMBLE;
-
+		txcmd->num_spatial_streams[0] = 1;
+		txcmd->bcc_or_ldpc = 0;
+		txcmd->stbc_enabled = 0;
 		return;
 	}
 
-	c = IEEE80211_SKB_CB(skb);
 	/* Some defaults*/
 	txcmd->num_rates = 0;
 	txcmd->stbc_enabled = 0;
@@ -201,12 +203,15 @@ static void get_rate(struct sk_buff *skb,
 	}
 
 	for (index = 0; index < 4; index++) {
+		bool skip_rate = false;
+
 		txrate = (&c->control.rates[index]);
 		txcmd->rate_flags[index] = 0;
 
 		if (txrate->idx < 0)
 			continue;
 
+		txcmd->num_rates++;
 		txcmd->num_spatial_streams[index] = 1;
 
 		/* production test*/
@@ -257,84 +262,79 @@ static void get_rate(struct sk_buff *skb,
 		 */
 
 		/* It is an VHT MCS rate */
-		if (((txrate->flags & IEEE80211_TX_RC_MCS) ||
-		     (txrate->flags & IEEE80211_TX_RC_VHT_MCS)) &&
-		    txrate->flags & IEEE80211_TX_RC_VHT_MCS) {
+		if (txrate->flags & IEEE80211_TX_RC_VHT_MCS) {
 			/*idx field is split
 			 * into a higher 4 bits (Nss), starts
 			 * with 0 and lower 4 bits (MCS number)
 			 */
 			is_mcs = true;
-			mcs_rate_num = (txrate->idx & 0x0F);
-			txcmd->num_spatial_streams[index] =
-				((txrate->idx & 0xF0) >> 4) + 1;
-			/* STBC Enabled/Disabled: valid Nss = 1 */
-			if (txcmd->num_spatial_streams[index] == 1 &&
-			    (c->flags & IEEE80211_TX_CTL_STBC))
-				txcmd->stbc_enabled = 1;
-
-		} else if (((txrate->flags & IEEE80211_TX_RC_MCS) ||
-			    (txrate->flags & IEEE80211_TX_RC_VHT_MCS)) &&
-			   txrate->flags & IEEE80211_TX_RC_MCS) { /*HT rate */
+			mcs_rate_num = ieee80211_rate_get_vht_mcs(txrate);
+			nss =  ieee80211_rate_get_vht_nss(txrate);
+			txcmd->rate_flags[index] |= ENABLE_VHT_FORMAT;
+		} else if (txrate->flags & IEEE80211_TX_RC_MCS) {
 			is_mcs = true;
 			mcs_rate_num  = txrate->idx;
-
-			/* Update No of Spatial streams*/
-			if (mcs_rate_num < 8) {
-				txcmd->num_spatial_streams[index] = 1;
-			} else if (mcs_rate_num > 7  &&
-				 mcs_rate_num < 16) {
-				txcmd->num_spatial_streams[index] = 2;
-			} else  {
-				pr_err("UCCP420_WIFI: Invalid MCS index: %d, Supports only 2 spatial streams\n",
-			       mcs_rate_num);
-			}
-
-			/* Ensures good throughput */
-			if (mcs_rate_num > 15 &&
-			    dev->params->uccp_num_spatial_streams == 1) {
-				mcs_rate_num = 7;
-				txcmd->num_spatial_streams[index] = 1;
-			} else if (mcs_rate_num > 15 &&
-				   dev->params->uccp_num_spatial_streams == 2) {
-				mcs_rate_num = 15;
-				txcmd->num_spatial_streams[index] = 2;
-			}
-
-			/* STBC Enabled/Disabled: valid for Nss=1 */
-			if (mcs_rate_num < 8 &&
-			    (c->flags & IEEE80211_TX_CTL_STBC))
-				txcmd->stbc_enabled = 1;
-
-		} else if (((txrate->flags & IEEE80211_TX_RC_MCS) ||
-			    (txrate->flags & IEEE80211_TX_RC_VHT_MCS))) {
-			is_mcs = true;
-			WARN_ON(1);
-		}
-
-		/* Rate FORMAT*/
-		if (txrate->flags & IEEE80211_TX_RC_VHT_MCS)
-			txcmd->rate_flags[index] |= ENABLE_VHT_FORMAT;
-		else if (txrate->flags & IEEE80211_TX_RC_MCS)
+			nss = mcs_rate_num/8 + 1;
 			txcmd->rate_flags[index] |= ENABLE_11N_FORMAT;
+		}
 
 		mcs_indx = dev->params->mgd_mode_tx_fixed_mcs_indx;
 		mgd_rate = dev->params->mgd_mode_tx_fixed_rate;
+		mgd_mcast_rate = dev->params->mgd_mode_mcast_fixed_data_rate;
 
 		/* Rate Index:
-		 * From proc (only for data packets)
+		 * From proc:
+		 *    ** Multicast data packets
+		 *    ** Unicast data packets
 		 * From RC in mac80211
 		 * Can be MCS(HT/VHT) or Rate (11abg)
 		 */
-		if (ieee80211_is_data(hdr->frame_control) && mcs_indx != -1) {
+		if (ieee80211_is_data(hdr->frame_control) &&
+		    is_multicast_ether_addr(hdr->addr1) &&
+		    (mgd_mcast_rate != -1)) {
+			/* proc: Fixed MCS/Legacy rate for Multicast packets
+			 */
+			is_mgd = true;
+			is_mcs = (mgd_mcast_rate & 0x80) == 0x80 ? true : false;
+
+			if (!is_mcs) {
+				if (mgd_mcast_rate == 55)
+					mgd_mcast_rate = 11;
+				else
+					mgd_mcast_rate *= 2;
+			}
+
+			txcmd->rate[index] = mgd_mcast_rate;
+			txcmd->rate_flags[index] =
+				dev->params->mgd_mode_mcast_fixed_rate_flags;
+			txcmd->bcc_or_ldpc =
+				dev->params->mgd_mode_mcast_fixed_bcc_or_ldpc;
+			if (txcmd->rate_flags[index] & ENABLE_11N_FORMAT)
+				nss = (mgd_mcast_rate & 0x7F)/8 + 1;
+			else
+				nss = dev->params->mgd_mode_mcast_fixed_nss;
+			txcmd->stbc_enabled =
+				dev->params->mgd_mode_mcast_fixed_stbc_enabled;
+			txcmd->rate_preamble_type[index] =
+				dev->params->mgd_mode_mcast_fixed_preamble;
+			if (is_mcs)
+				update_mcs_packet_stat(mgd_mcast_rate & 0x7F,
+						       txcmd->rate_flags[index],
+						       dev);
+		} else if (ieee80211_is_data(hdr->frame_control) &&
+			   mcs_indx != -1) {
+			/* proc: Fixed MCS for unicast
+			 */
 			is_mgd = true;
 
 			txcmd->rate[index] = 0x80;
 			txcmd->rate[index] |= (mcs_indx);
 			txcmd->rate_flags[index] =
 				dev->params->prod_mode_rate_flag;
-			txcmd->num_spatial_streams[index] =
-				dev->params->num_spatial_streams;
+			if (txcmd->rate_flags[index] & ENABLE_11N_FORMAT)
+				nss = (mcs_indx)/8 + 1;
+			else
+				nss = dev->params->num_spatial_streams;
 			txcmd->bcc_or_ldpc =
 				dev->params->prod_mode_bcc_or_ldpc;
 			txcmd->stbc_enabled =
@@ -345,6 +345,8 @@ static void get_rate(struct sk_buff *skb,
 					       dev);
 		} else if (ieee80211_is_data(hdr->frame_control) &&
 			   mgd_rate != -1) {
+			/* proc: Fixed Legacy Rate for unicast
+			 */
 			is_mgd = true;
 			txcmd->rate[index] = 0x80;
 			txcmd->rate[index] = 0x00;
@@ -355,34 +357,51 @@ static void get_rate(struct sk_buff *skb,
 				txcmd->rate[index] |= ((mgd_rate * 10) / 5);
 
 			txcmd->rate_flags[index] = 0;
-			txcmd->num_spatial_streams[index]  = 1;
+			nss = 1;
 			txcmd->bcc_or_ldpc         = 0;
 			txcmd->stbc_enabled        = 0;
-		} else if (is_mcs) { /* idx is MCS */
-			/* Now mark MSB to tell LMAC that it is a MCS Index */
-			txcmd->rate[index] = 0x80;
+			txcmd->rate_preamble_type[index] =
+				dev->params->prod_mode_rate_preamble_type;
+		} else if (is_mcs) {
+			txcmd->rate[index] = MARK_RATE_AS_MCS_INDEX;
 			txcmd->rate[index] |= mcs_rate_num;
 			update_mcs_packet_stat(mcs_rate_num,
 					      txcmd->rate_flags[index],
 					      dev);
-		} else if (!is_mcs) { /* idx is RATE...*/
+		} else if (!is_mcs) {
 			rate = &dev->hw->wiphy->bands[
 				c->band]->bitrates[
 				c->control.rates[index].idx];
-			/* Now mark MSB to tell LMAC that it is a rate*/
-			txcmd->rate[index] = 0x00;
+			txcmd->rate[index] = MARK_RATE_AS_RATE;
 			txcmd->rate[index] |= rate->hw_value;
-			/* using rate so 11g/11b/11a */
-			txcmd->num_spatial_streams[index] = 1;
+			nss = 1;
 		}
 
-		if (txcmd->rate_flags[index] & ENABLE_VHT_FORMAT) {
+		txcmd->num_spatial_streams[index] = nss;
+		if (txcmd->rate_flags[index] & ENABLE_VHT_FORMAT)
 			/*Enabled for all ucast/bcast/mcast frames*/
 			txcmd->aggregate_mpdu = AMPDU_AGGR_ENABLED;
+
+		if (is_mgd) {
+			if (dev->params->rate_protection_type)
+				txcmd->rate_protection_type[index] =
+					USE_PROTECTION_RTS;
+			else
+				txcmd->rate_protection_type[index] =
+					USE_PROTECTION_NONE;
+			txcmd->rate_retries[index] = 1;
+			all_rates_invalid = false;
+			break;
 		}
 
+		/* STBC Enabled/Disabled: valid if n_antennas > Nss */
+		if (dev->params->uccp_num_spatial_streams > nss &&
+		    (c->flags & IEEE80211_TX_CTL_STBC))
+			txcmd->stbc_enabled = 1;
+
 		txcmd->rate_retries[index] =
 			c->control.rates[index].count;
+
 		if (c->control.rates[index].flags &
 		    IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
 			txcmd->rate_preamble_type[index] =
@@ -392,7 +411,6 @@ static void get_rate(struct sk_buff *skb,
 				DONT_USE_SHORT_PREAMBLE;
 
 		prot_type = USE_PROTECTION_NONE;
-
 		if (dev->params->rate_protection_type == 1) {
 			/* Protection*/
 			if (c->control.rates[index].flags &
@@ -424,7 +442,7 @@ static void get_rate(struct sk_buff *skb,
 			    ieee80211_has_protected(hdr->frame_control)) {
 				if (skb->len +
 				    c->control.hw_key->icv_len +
-				    FCS_LEN > dev->rts_threshold)
+				    dev->rts_threshold < FCS_LEN)
 					prot_type = USE_PROTECTION_RTS;
 			}
 
@@ -436,39 +454,39 @@ static void get_rate(struct sk_buff *skb,
 
 		}
 
-		/*No 3rd party device is using this, so diable for now*/
+		/*No 3rd party device is using this, so disable for now*/
 		if (txcmd->rate_flags[index] & ENABLE_VHT_FORMAT)
 			prot_type = USE_PROTECTION_NONE;
 
 		txcmd->rate_protection_type[index] = prot_type;
 
 
-		/* Do not set the flags for Managed Mode, they will come
-		 * from proc
-		 */
-		if (!is_mgd) {
-			if (c->control.rates[index].flags &
-					IEEE80211_TX_RC_GREEN_FIELD)
-				txcmd->rate_flags[index] |=
-						ENABLE_GREEN_FIELD;
-			if (c->control.rates[index].flags &
-					IEEE80211_TX_RC_40_MHZ_WIDTH)
-				txcmd->rate_flags[index] |=
-						ENABLE_CHNL_WIDTH_40MHZ;
-			if (c->control.rates[index].flags &
-					IEEE80211_TX_RC_80_MHZ_WIDTH)
-				txcmd->rate_flags[index] |=
-					ENABLE_CHNL_WIDTH_80MHZ;
-			if (c->control.rates[index].flags &
-					IEEE80211_TX_RC_SHORT_GI)
-				txcmd->rate_flags[index] |= ENABLE_SGI;
-		}
+		if (c->control.rates[index].flags &
+				IEEE80211_TX_RC_GREEN_FIELD)
+			txcmd->rate_flags[index] |=
+					ENABLE_GREEN_FIELD;
+		if (c->control.rates[index].flags &
+				IEEE80211_TX_RC_40_MHZ_WIDTH)
+			txcmd->rate_flags[index] |=
+					ENABLE_CHNL_WIDTH_40MHZ;
+		if (c->control.rates[index].flags &
+				IEEE80211_TX_RC_80_MHZ_WIDTH)
+			txcmd->rate_flags[index] |=
+				ENABLE_CHNL_WIDTH_80MHZ;
+		if (c->control.rates[index].flags &
+				IEEE80211_TX_RC_SHORT_GI)
+			txcmd->rate_flags[index] |= ENABLE_SGI;
 
 		/*Some Sanity Checks*/
-		/* Nss-1/2 */
-		if (txcmd->num_spatial_streams[index] <= 0 ||
-				txcmd->num_spatial_streams[index] > 2)
-			txcmd->num_spatial_streams[index] = 1;
+		if (nss <= max(MAX_TX_STREAMS, MAX_RX_STREAMS))
+			/*Got at-least one valid rate*/
+			all_rates_invalid = false;
+		else {
+			if (net_ratelimit())
+				UCCP_DEBUG_IF("UCCP420_WIFI:Skip Nss: %d\n",
+					      nss);
+			skip_rate = true;
+		}
 
 		/* VHT 20MHz MCS9 is not valid*/
 		if (txrate->flags & IEEE80211_TX_RC_VHT_MCS &&
@@ -477,8 +495,7 @@ static void get_rate(struct sk_buff *skb,
 			  ENABLE_CHNL_WIDTH_40MHZ) &&
 			!(txcmd->rate_flags[index] &
 			  ENABLE_CHNL_WIDTH_80MHZ))
-				/* Downgrade to VHT-MCS8-Nss-1 */
-			txcmd->rate[index] = 0x88;
+			skip_rate = true;
 
 		/*First Time*/
 #ifdef notyet
@@ -500,8 +517,23 @@ static void get_rate(struct sk_buff *skb,
 				  dev->name);
 		}
 #endif
+		if (skip_rate)
+			txcmd->rate_retries[index] = 0;
 
-		txcmd->num_rates++;
+	}
+
+	if (all_rates_invalid) {
+		/*use min supported rate*/
+		if (net_ratelimit())
+			UCCP_DEBUG_IF("UCCP420_WIFI:invalid rates\n");
+		txcmd->num_rates = 1;
+		txcmd->rate[0] = min_rate;
+		txcmd->rate_retries[0] = 5;
+		txcmd->rate_protection_type[0] = USE_PROTECTION_NONE;
+		txcmd->rate_preamble_type[0] = DONT_USE_SHORT_PREAMBLE;
+		txcmd->num_spatial_streams[0] = 1;
+		txcmd->bcc_or_ldpc = 0;
+		txcmd->stbc_enabled = 0;
 	}
 }
 
@@ -532,7 +564,8 @@ static int uccp420wlan_send_cmd(unsigned char *buf,
 
 	if (!nbuf) {
 		rcu_read_unlock();
-		return -1;
+		WARN_ON(1);
+		return -ENOMEM;
 	}
 	hdr->id = id;
 	hdr->length = len;
@@ -677,9 +710,8 @@ int uccp420wlan_proc_tx(void)
 	tx_cmd.num_frames_per_desc = skb_queue_len(skb_list);
 	tx_cmd.pkt_gram_payload_len = hdrlen;
 	tx_cmd.aggregate_mpdu = AMPDU_AGGR_DISABLED;
+	tx_cmd.rate_retries[index] = 1;
 
-	/* production test*/
-	tx_cmd.num_rates = 1;
 	if (dev->params->tx_fixed_mcs_indx != -1) {
 		tx_cmd.rate_preamble_type[index] =
 			dev->params->prod_mode_rate_preamble_type;
@@ -1255,46 +1287,46 @@ int uccp420wlan_prog_channel(unsigned int prim_ch,
 		}
 	dev = p->context;
 	if (dev->params->production_test == 1) {
-			if ((dev->params->prod_mode_chnl_bw_40_mhz == 1) &&
-				(dev->params->sec_ch_offset_40_minus == 1)) {
-				/*  NL80211_CHAN_HT40MINUS */
-				ch_width = 2;
-				cf_offset -= 10;
-			} else if (dev->params->prod_mode_chnl_bw_40_mhz == 1) {
-				/* NL80211_CHAN_HT40PLUS */
-				ch_width = 2;
-				cf_offset += 10;
-			}
+		if ((dev->params->prod_mode_chnl_bw_40_mhz == 1) &&
+			(dev->params->sec_ch_offset_40_minus == 1)) {
+			/*  NL80211_CHAN_HT40MINUS */
+			ch_width = 2;
+			cf_offset -= 10;
+		} else if (dev->params->prod_mode_chnl_bw_40_mhz == 1) {
+			/* NL80211_CHAN_HT40PLUS */
+			ch_width = 2;
+			cf_offset += 10;
+		}
 
-			is_vht_bw80 = vht_support &&
-				(dev->params->prod_mode_chnl_bw_80_mhz == 1);
+		is_vht_bw80 = vht_support &&
+			(dev->params->prod_mode_chnl_bw_80_mhz == 1);
 
-			is_vht_bw80_sec_40minus = is_vht_bw80 &&
-				(dev->params->sec_ch_offset_40_minus == 1);
+		is_vht_bw80_sec_40minus = is_vht_bw80 &&
+			(dev->params->sec_ch_offset_40_minus == 1);
 
-			is_vht_bw80_sec_40plus = is_vht_bw80 &&
-				(dev->params->sec_ch_offset_40_plus == 1);
+		is_vht_bw80_sec_40plus = is_vht_bw80 &&
+			(dev->params->sec_ch_offset_40_plus == 1);
 
-			if (is_vht_bw80)
-				ch_width = 3;
+		if (is_vht_bw80)
+			ch_width = 3;
 
-			if (is_vht_bw80_sec_40minus &&
-			    (dev->params->sec_40_ch_offset_80_minus == 1))
-				cf_offset -= 30;
-			else if (is_vht_bw80_sec_40minus &&
-				 (dev->params->sec_40_ch_offset_80_plus == 1))
-				cf_offset += 10;
-			else if (is_vht_bw80_sec_40minus)/* default */
-				cf_offset -= 30;
+		if (is_vht_bw80_sec_40minus &&
+		    (dev->params->sec_40_ch_offset_80_minus == 1))
+			cf_offset -= 30;
+		else if (is_vht_bw80_sec_40minus &&
+			 (dev->params->sec_40_ch_offset_80_plus == 1))
+			cf_offset += 10;
+		else if (is_vht_bw80_sec_40minus)/* default */
+			cf_offset -= 30;
 
-			if (is_vht_bw80_sec_40plus &&
-			    (dev->params->sec_40_ch_offset_80_minus == 1))
-				cf_offset -= 10;
-			else if (is_vht_bw80_sec_40plus &&
-				 (dev->params->sec_40_ch_offset_80_plus == 1))
-				cf_offset += 30;
-			else if (is_vht_bw80_sec_40plus)/* default */
-				cf_offset -= 10;
+		if (is_vht_bw80_sec_40plus &&
+		    (dev->params->sec_40_ch_offset_80_minus == 1))
+			cf_offset -= 10;
+		else if (is_vht_bw80_sec_40plus &&
+			 (dev->params->sec_40_ch_offset_80_plus == 1))
+			cf_offset += 30;
+		else if (is_vht_bw80_sec_40plus)/* default */
+			cf_offset -= 10;
 
 
 	}
@@ -1701,9 +1733,8 @@ int uccp420wlan_prog_tx(unsigned int queue,
 				dev->stats->tx_cmd_send_count_single++;
 			else if (skb_queue_len(txq) > 1)
 				dev->stats->tx_cmd_send_count_multi++;
-		} else {
+		} else
 			dev->stats->tx_cmd_send_count_beaconq++;
-		}
 #ifdef PERF_PROFILING
 	}
 #endif
@@ -2187,6 +2218,17 @@ int uccp420wlan_prog_econ_ps_state(int if_index,
 }
 #endif
 
+int uccp420wlan_prog_tx_deinit(int vif_index, char *peer_addr)
+{
+	struct cmd_tx_deinit cmd_tx_deinit;
+
+	memset(&cmd_tx_deinit, 0, (sizeof(struct cmd_tx_deinit)));
+	cmd_tx_deinit.if_index = vif_index;
+	ether_addr_copy(cmd_tx_deinit.peer_addr, peer_addr);
+	return uccp420wlan_send_cmd((unsigned char *) &cmd_tx_deinit,
+				    sizeof(struct cmd_tx_deinit),
+				    UMAC_CMD_TX_DEINIT);
+}
 
 int uccp420wlan_msg_handler(void *nbuff,
 			    unsigned char sender_id)
@@ -2238,7 +2280,7 @@ int uccp420wlan_msg_handler(void *nbuff,
 				     cmd_info.outstanding_ctrl_req);
 			pending_cmd = skb_dequeue(&cmd_info.outstanding_cmd);
 
-			if (unlikely(pending_cmd != NULL)) {
+			if (likely(pending_cmd != NULL)) {
 				UCCP_DEBUG_IF("Send 1 outstanding cmd\n");
 				hal_ops.send((void *)pending_cmd, HOST_MOD_ID,
 					     UMAC_MOD_ID, 0);
@@ -2266,8 +2308,7 @@ int uccp420wlan_msg_handler(void *nbuff,
 			(struct host_event_scanres *) buff,
 			buff +  sizeof(struct host_event_scanres), skb->len);
 
-	} else if (event == UMAC_EVENT_RX /* ||
-		   event == EVENT_RX_MIC_FAILURE*/) {
+	} else if (event == UMAC_EVENT_RX) {
 		if (dev->params->production_test) {
 			dev->stats->rx_packet_data_count++;
 			dev_kfree_skb_any(skb);
@@ -2417,6 +2458,8 @@ int uccp420wlan_msg_handler(void *nbuff,
 					     p->context);
 
 #endif
+	} else if (event == UMAC_EVENT_TX_DEINIT_DONE) {
+		dev->tx_deinit_complete = 1;
 	} else if (event == UMAC_EVENT_FW_ERROR) {
 		pr_err("%s: FW is in Error State, please reload.\n", __func__);
 	} else {
-- 
2.6.2

